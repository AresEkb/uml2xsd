/**
 * Copyright (c) 2015 Denis Nikiforov.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *    Denis Nikiforov - initial API and implementation
 */

import uml2xsd.UtilitiesLibrary;
import OCLtoXPath;

modeltype UML uses 'http://www.eclipse.org/uml2/2.1.0/UML';
modeltype OCL 'strict' uses 'http://www.eclipse.org/ocl/2015/Pivot';
modeltype XSD uses 'http://www.w3.org/2001/XMLSchema';
modeltype VC uses 'http://www.w3.org/2007/XMLSchema-versioning';
modeltype XPATH2 'strict' uses 'http://www.emftext.org/language/xpath2';
modeltype ECORE uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype TYPE uses 'http://www.eclipse.org/emf/2003/XMLType';

transformation ISO20022toXSD11(in m : UML, out x : XSD);

main()
{
    m.objectsOfType(Signal)->select(is('MessageDefinition'))->toSchema();
}

query Element::is(stereotypeName : String) : Boolean =
    self.getAppliedStereotypes()->union(self.getAppliedStereotypes().allParents().oclAsType(Stereotype))
        ->select(owner.oclAsType(Profile).name = 'ISO20022Profile')
        ->exists(name = stereotypeName);

mapping Classifier::toSchema() : DocumentRoot
{
    log('  Found message ' + self.name);
    var schemaObj := object SchemaType {
        targetNamespace := 'urn:iso:std:iso:20022:tech:xsd:pain.001.001.03' + self.name; // @TODO
        anyAttribute := createFeatureMapEntry('http://www.w3.org/2007/XMLSchema-versioning', 'minVersion', '1.1');
        elementFormDefault := FormChoice::qualified;
    };

    xMLNSPrefixMap += object EStringToStringMapEntry {
        value := 'urn:iso:std:iso:20022:tech:xsd:pain.001.001.03' + self.name;
    };
    
    schemaObj.element += object TopLevelElement {
    	name := 'Document';
    	type := createQName('Document').oclAsType(QName);
    };

    schemaObj.complexType += object TopLevelComplexType {
        name := 'Document';
        sequence := object ExplicitGroup {
            element := self.attribute->collect(attr|object LocalElement {
                name := attr.name;
                type := createQName(attr.type.name).oclAsType(QName);
            });
        };
    };

    self.oclAsType(Classifier)->closure(attribute.type.oclAsType(Classifier))->sortedBy(name)->forEach (obj) {
        //log(obj.name + ' ' + obj.getAppliedStereotypes().name->any(true));
        if obj.is('MessageComponent') then {
    	   schemaObj.complexType += obj->toComplexType(schemaObj);
    	}
     	elif obj.is('ChoiceComponent') then {
           //schemaObj.complexType += obj->toComplexType(schemaObj);
    	}
        elif obj.is('CodeSet') then {
           schemaObj.simpleType += obj.oclAsType(DataType)->toSimpleType2();
        }
        elif obj.is('IdentifierSet') then {
           //schemaObj.complexType += obj->toComplexType(schemaObj);
        }
        elif obj.is('Datatype') then {
           schemaObj.simpleType += obj.oclAsType(DataType)->toSimpleType();
        }
    	else {
    	   assert fatal (false) with log('Mapping of classifiers with ' + obj.getAppliedStereotypes().name->sortedBy(str|str)->sep(',') + ' stereotype is not supported');
    	} endif;
    };

    schema := schemaObj;
    
    /*
    xMLNSPrefixMap += resolveIn(Expr::findQNames, SchemaQNames)
        ->select(schema=schemaObj).qnames
        ->collect(qname|object EStringToStringMapEntry {
            key := qname.getPrefix();
            value := qname.getNamespaceURI();
        });*/
}

mapping DataType::toSimpleType() : TopLevelSimpleType
{
    var types : Dict(String, String);
    types->put('Decimal', 'decimal');
    types->put('Binary', 'base64Binary');
    types->put('Boolean', 'boolean');
    types->put('String', 'string');
    types->put('DateTime', 'dateTime');
    types->put('Date', 'date');
    types->put('Time', 'time');
    types->put('Month', 'gMonth');
    types->put('Year', 'gYear');
    types->put('Day', 'gDay');
    types->put('Duration', 'duration');
    types->put('MonthDay', 'gMonthDay');
    types->put('YearMonth', 'gYearMonth');

    var stereotypes := self.getAppliedStereotypes()->union(self.getAppliedStereotypes().allParents().oclAsType(Stereotype))
        ->select(owner.oclAsType(Profile).name = 'ISO20022Profile')
        ->select(types->hasKey(name));

    assert fatal (stereotypes->size() = 1) with log('DataType "' + self.getAppliedStereotypes().name->sortedBy(str|str)->sep(',') + '" ' + self.name + ' must have exactly one stereotype inherited from Datatype stereotype');
    var stereotype := stereotypes->any(true).name;
    
    name := self.name;
    restriction := object RestrictionType1 {
        base := createQName('http://www.w3.org/2001/XMLSchema', types->get(stereotype), 'xs');
        facetGroup := self.getFacetGroup();
    };
}

mapping DataType::toSimpleType2() : TopLevelSimpleType
{
    name := self.name;
    restriction := object RestrictionType1 {
        base := createQName('http://www.w3.org/2001/XMLSchema', 'string', 'xs');
        facetGroup := self.getFacetGroup();
    };
}

mapping Classifier::toComplexType(schema : SchemaType) : TopLevelComplexType
when { self.getAllAttributes()->notEmpty() }
{
    name := self.name;
    //attribute := self.getOwnedAttributes()->toAttribute();
    sequence := self.map toExplicitGroup();
    _assert := self.ownedRule.xmap toAssertion(schema);
}

mapping Class::toElement() : TopLevelElement
{
    name := self.name;
    // TODO: Annotation will be contained in element itself in a new model version
    //annotation := self.attribute->any(true).getAnnotation();
    // TODO: Property will be named 'value' in a new model version
    var dataType := self.attribute->any(true/*name = 'value'*/).type;
    type := dataType.getQName();
}

mapping Property::toAttribute() : Attribute
{
    name := self.name;
    type := self.type.getQName();
    if (self.lower = 1 and self.upper = 1) {
        use := UseType::required;
    } 
    elif (self.lower = 0 and self.upper = 1) {
        use := UseType::optional;
    } 
    elif (self.lower = 0 and self.upper = 0) {
        use := UseType::prohibited;
    } 
}

mapping Classifier::toExplicitGroup() : ExplicitGroup
when { self.getAttributes()->notEmpty() }
{
    element := self.getAttributes()->toLocalElement();
}

mapping Property::toLocalElement() : LocalElement
{
    name := self.name;
    type := self.type.getUnprefixedQName();
    if (self.lower = 0 or self.lower > 1) {
        minOccurs := self.lower.toBigInteger();
    };
    if (self.upper <> 1) {
        maxOccurs := if self.upper = -1 then AllNNIMember1::unbounded else self.upper.toBigInteger() endif;
    };
}

query NamedElement::getQName() : QName =
    createQName(self.name).oclAsType(QName);

query NamedElement::getUnprefixedQName() : QName =
    createQName(self.name).oclAsType(QName);

mapping Constraint::toAssertion(schema : SchemaType) : Assertion
{
    var xpath := self.toExpressionInOCL().xmap toXPath();
    xpath.xmap findQNames(schema);
    test := xpath.toString();
    //annotation := self.getAnnotation();
}

intermediate class SchemaQNames { schema : SchemaType; qnames : Set(QName); };

mapping Expr::findQNames(currentSchema : SchemaType) : SchemaQNames
{
    schema := currentSchema;
    qnames := self.allSubobjects()[EObject]->collect(
                    obj|obj.eClass().eAttributes->collect(attr|obj.eGet(attr)))
                ->selectByKind(QName).oclAsSet()
                ->select(getPrefix() <> null and getNamespaceURI() <> null)->asSet();
}
/*
mapping String::toAnnotation() : AnnotationType
when { self.size() > 0 }
{
    documentation := object DocumentationType {
        mixed := createFeatureMapEntry('http://www.eclipse.org/emf/2003/XMLType', 'text',
            self.replaceAll('&nbsp;', ' ').replaceAll('\r\n', '\n').replaceAll('\n', ' '));
    };
}
*/
///////////////////////////////////////////////////////////////////////////////
// Helpers
/*
query Package::getSchemaLocation() : String =
    self.getTargetNS().replaceAll('^urn:', '').substituteAll(':', '_') + '.xsd';

query Package::isXMLPT() : Boolean =
    self.getTargetNS() = 'http://www.w3.org/2001/XMLSchema';

query Classifier::getOwnedAttributes() : Sequence(Property) =
    self.getAttributes()->select(getAppliedStereotype('EECProfile::Attribute') <> null);

query Classifier::getOwnedElements() : Sequence(Property) =
    self.getAttributes()->select(getAppliedStereotype('EECProfile::Attribute') = null);

query Classifier::hasComplexContent() : Boolean =
    if self.getOwnedElements()->notEmpty() then true
    else self.general->hasComplexContent()->exists(b|b=true) endif;

query Package::isNamespace() : Boolean =
    self.getAppliedStereotype('EECProfile::Namespace') <> null;

query Generalization::isRestriction() : Boolean =
    self.getAppliedStereotype('EECProfile::restriction') <> null;

query Element::getAnnotation() : AnnotationType =
    self.ownedComment.body->toAnnotation()->any(true);

query EnumerationLiteral::getAnnotation() : AnnotationType =
    self.specification[OpaqueExpression].body->toAnnotation()->any(true);
*/
query DataType::getFacetGroup() : List(EFeatureMapEntry)
{
    var facetGroup : List(EFeatureMapEntry);
    facetGroup += self.createFacet('minInclusive');
    facetGroup += self.createFacet('minExclusive');
    facetGroup += self.createFacet('maxInclusive');
    facetGroup += self.createFacet('maxExclusive');
    facetGroup += self.createTotalDigitsType('totalDigits');
    facetGroup += self.createNumFacet('fractionDigits');
    facetGroup += self.createNumFacet('length');
    facetGroup += self.createNumFacet('minLength');
    facetGroup += self.createNumFacet('maxLength');
    facetGroup += self.createPatternType('pattern');
    facetGroup += self[Enumeration].createNoFixedFacet('enumeration');
    return facetGroup;
}

query DataType::createFacet(name : String) : Bag(EFeatureMapEntry) =
    let val = self.getValue('EECProfile::ValueDomain', name) in
    if val <> null
        then Bag{ createFeatureMapEntry('http://www.w3.org/2001/XMLSchema', name, object Facet { value := val }) }
        else Bag{} endif;

query DataType::createNumFacet(name : String) : Bag(EFeatureMapEntry) =
    let val = self.getValue('EECProfile::ValueDomain', name) in
    if val <> null
        then Bag{ createFeatureMapEntry('http://www.w3.org/2001/XMLSchema', name, object NumFacet { value := val }) }
        else Bag{} endif;

query DataType::createTotalDigitsType(name : String) : Bag(EFeatureMapEntry) =
    let val = self.getValue('EECProfile::ValueDomain', name) in
    if val <> null
        then Bag{ createFeatureMapEntry('http://www.w3.org/2001/XMLSchema', name, object TotalDigitsType { value := val }) }
        else Bag{} endif;

query DataType::createPatternType(name : String) : Bag(EFeatureMapEntry) =
    let val = self.getValue('EECProfile::ValueDomain', name) in
    if val <> null
        then Bag{ createFeatureMapEntry('http://www.w3.org/2001/XMLSchema', name, object PatternType { value := val }) }
        else Bag{} endif;

// TODO: Sorting doesn't work
query Enumeration::createNoFixedFacet(name : String) : Sequence(EFeatureMapEntry) =
    self.ownedLiteral->sortedBy(name)
        ->collect(val|createFeatureMapEntry('http://www.w3.org/2001/XMLSchema',
            name, object NoFixedFacet { value := val.name; /*annotation := val.getAnnotation();*/ }));

query Sequence(String)::sep(separator : String) : String =
    self->iterate(str; res : String = '' | if res = '' then str else res + separator + str endif);
