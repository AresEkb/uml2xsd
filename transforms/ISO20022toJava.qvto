/**
 * Copyright (c) 2015, 2016 Denis Nikiforov.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Denis Nikiforov - initial API and implementation
 */

import uml2xsd.UtilitiesLibrary;
import ISO20022Helpers;
import JavaHelpers;
import OCLtoXPath;
import DocOCL;

modeltype UML uses 'http://www.eclipse.org/uml2/2.1.0/UML';
modeltype OCL 'strict' uses 'http://www.eclipse.org/ocl/2015/Pivot';
modeltype JAVA uses 'http://www.emftext.org/java';
modeltype ECORE uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype TYPE uses 'http://www.eclipse.org/emf/2003/XMLType';
modeltype XPATH2 'strict' uses 'http://www.emftext.org/language/xpath2';

transformation ISO20022toJava(in m : UML, out j : JAVA);

exception IllegalArgumentException { }

intermediate class Param { name : String; xpath : OCLExpression; type : String };

//property params : Dict(OCLExpression, Set(Param));

/**
 * Find all message definitions and map them to compilation units
 */
main()
{
    useFunctionQNames := true;
    emptySelf := true;
    m.objectsOfKind(Classifier)->select(is('MessageDefinition'))->toCompilationUnit();
}

/**
 * Map a message definition to the following compilation unit:
 *
 * package com.centreit.repiso.validator.validation;
 *
 * import java.util.Arrays;
 * import java.util.List;
 * import javax.annotation.Generated;
 * import org.w3c.dom.Node;
 * import com.centreit.repiso.validator.validation.BaseValidator;
 * import com.centreit.repiso.validator.validation.Helper;
 * import com.centreit.repiso.validator.validation.RuleMetadata;
 * import com.centreit.repiso.validator.validation.RuleResult;
 * import com.centreit.repiso.validator.validation.Variable;
 *
 * @Generated("uml2xsd")
 * public class {name} extends BaseValidator {
 *
 *     {validation methods}
 * }
 *
 */
mapping Classifier::toCompilationUnit() : JAVA::containers::CompilationUnit
{
    var className := self.name.toIdentifier();
    log('  Found message ' + self.name);

    name := self.name;
    namespaces := 'com.centreit.repiso.validator.validation'.tokenize('.');

    addClassImport(result, 'java.util.Arrays');
    addInterfaceImport(result, 'java.util.List');
    addAnnotationImport(result, 'javax.annotation.Generated');
    addInterfaceImport(result, 'org.w3c.dom.Node');
    addClassImport(result, 'com.centreit.repiso.validator.validation.BaseValidator');
    addClassImport(result, 'com.centreit.repiso.validator.validation.Helper');
    addClassImport(result, 'com.centreit.repiso.validator.validation.RuleResult');
    addClassImport(result, 'com.centreit.repiso.validator.validation.RuleMetadata');
    addClassImport(result, 'com.centreit.repiso.validator.validation.Variable');

    classifiers := object JAVA::classifiers::Class {
        name := className;

        _extends := result.getClassReference('com.centreit.repiso.validator.validation.BaseValidator');

        annotationsAndModifiers += object JAVA::annotations::AnnotationInstance {
            annotation := result.getAnnotation('javax.annotation.Generated');
            parameter := object JAVA::annotations::SingleAnnotationParameter {
            	value := object JAVA::_references::StringReference { value := 'uml2xsd'; };
            };
        };
        annotationsAndModifiers += object JAVA::modifiers::Public { };

        var rootField := object JAVA::members::Field {
            name := 'root';
            typeReference := result.getClassReference('org.w3c.dom.Node');
            annotationsAndModifiers := object JAVA::modifiers::Private { };
        };

        members += self.ownedRule->sortedBy(name)->toValidationMethod(rootField);
    };
}

/**
 * Map OCL constraint to the following validation method:
 *
 *     @RuleMetadata(id = "{rule id}",
 *                   name= "{rule name}",
 *                   description = "{rule description}",
 *                   source = "{rule source}",
 *                   ocl = "{rule OCL}")
 *     public void check{rule id}(List<RuleResult> results) {
 *         {validation code}
 *     }
 *
 */
mapping Constraint::toValidationMethod(rootField : JAVA::members::Field) : JAVA::members::ClassMethod
{
    log('    Found rule ' + self.name);
    var rule := self.xmap toRule();
    name := 'check' + rule.id.toIdentifier().capitalize();

    annotationsAndModifiers += object JAVA::annotations::AnnotationInstance {
        annotation := result.getClass('com.centreit.repiso.validator.validation.RuleMetadata');
        parameter := object JAVA::annotations::AnnotationParameterList {
            settings += object JAVA::annotations::AnnotationAttributeSetting {
                attribute := object JAVA::members::InterfaceMethod { name := 'id' };
                value := object JAVA::_references::StringReference { value := rule.id };
            };
            if (notEmpty(rule.name)) {
                settings += object JAVA::annotations::AnnotationAttributeSetting {
                    attribute := object JAVA::members::InterfaceMethod { name := 'name' };
                    value := object JAVA::_references::StringReference { value := rule.name };
                };
            };
            settings += object JAVA::annotations::AnnotationAttributeSetting {
                attribute := object JAVA::members::InterfaceMethod { name := 'description' };
                value := object JAVA::_references::StringReference { value := rule.description };
            };
            if (notEmpty(rule.source)) {
                settings += object JAVA::annotations::AnnotationAttributeSetting {
                    attribute := object JAVA::members::InterfaceMethod { name := 'source' };
                    value := object JAVA::_references::StringReference { value := rule.source };
                };
            };
            settings += object JAVA::annotations::AnnotationAttributeSetting {
                attribute := object JAVA::members::InterfaceMethod { name := 'ocl' };
                value := object JAVA::_references::StringReference { value := rule.ocl };
            };
        };
    };
    annotationsAndModifiers += object JAVA::modifiers::Public { };

    var resultParam := object JAVA::parameters::OrdinaryParameter {
        name := 'results';
        typeReference := object JAVA::types::ClassifierReference {
            target := result.getInterface('java.util.List');
            typeArguments := object JAVA::generics::QualifiedTypeArgument {
                typeReference := result.getClassReference('com.centreit.repiso.validator.validation.RuleResult');
            };
        };
    };

    typeReference := object JAVA::types::Void { };
    parameters := resultParam;

    try {
        var variables : Dict(OCL::Variable, XPATH2::ExprSingle);
        var expr := self.toExpressionInOCL();
        assert fatal (not expr.ownedContext.oclIsInvalid());

        var variableName := '__' + expr.ownedContext.name.toIdentifier();
        variables->put(expr.ownedContext, object VarRef { varName := createQName(variableName) });
        
        var localVariables : List(JAVA::_references::ReferenceableElement);
        statements += object JAVA::statements::LocalVariableStatement {
            variable := object JAVA::variables::LocalVariable {
                name := variableName;
                typeReference := result.getClassReference('com.centreit.repiso.validator.validation.Variable');
                initialValue := object JAVA::_references::IdentifierReference {
                    target := object JAVA::classifiers::Class { name := 'Helper'; };
                    next := object JAVA::_references::MethodCall {
                        target := object JAVA::members::ClassMethod { name := 'variable'; };
                        arguments += object JAVA::_references::IdentifierReference {
                            target := rootField;
                        };
                        arguments += object JAVA::_references::StringReference {
                            value := variableName;
                        };
                    };
                };
            };
            localVariables->add(variable);
        };

        statements += self.xmap toValidationCode(expr.ownedBody, expr.ownedContext, expr.ownedContext, variables, rootField, resultParam, localVariables);
    }
    except () {
        log('WARNING: Unable to generate validation code');
    };
    // This code can't be moved into exception handling section, because it seems that sometimes exceptions aren't raised 
    if (statements->isEmpty()) {
        statements += object JAVA::statements::Throw {
            throwable := object JAVA::instantiations::NewConstructorCall {
                typeReference := result.getClassReference('java.lang.UnsupportedOperationException');
            };
        };
    };
}

mapping Constraint::toValidationCode(
    expr : OCLExpression,
    root : OCL::Variable,
    context : OCL::Variable,
    variables : Dict(OCL::Variable, XPATH2::ExprSingle),
    contextVariable : JAVA::_references::ReferenceableElement,
    resultVariable : JAVA::_references::ReferenceableElement,
    localVariables : List(JAVA::_references::ReferenceableElement)) : List(JAVA::statements::Statement)
disjuncts
    Constraint::toLet,
    Constraint::toForAll,
    Constraint::toHelperCheckInvocation
{
}

/**
 * Map OCL constraint to the variable declaration:
 *
 *         Variable {variable name} = Helper.variable({context variable}, "{variable name}", "{variable init expression}");
 *         {validation code}
 */
mapping Constraint::toLet(
    expr : OCLExpression,
    root : OCL::Variable,
    context : OCL::Variable,
    variables : Dict(OCL::Variable, XPATH2::ExprSingle),
    contextVariable : JAVA::_references::ReferenceableElement,
    resultVariable : JAVA::_references::ReferenceableElement,
    localVariables : List(JAVA::_references::ReferenceableElement)) : List(JAVA::statements::Statement)
when { expr.isLet() }
{
    var variableExpr := expr![LetExp].ownedVariable;
    var variableName := variableExpr.name.toIdentifier();
    var variables2 = variables;
    variables2->put(variableExpr, object VarRef { varName := createQName(variableName) });
    var localVariables2 := localVariables;
    result += object JAVA::statements::LocalVariableStatement {
        variable := object JAVA::variables::LocalVariable {
            name := '__' + variableName;
            typeReference := contextVariable.getClassReference('com.centreit.repiso.validator.validation.Variable');
            initialValue := object JAVA::_references::IdentifierReference {
                target := object JAVA::classifiers::Class { name := 'Helper'; };
                next := object JAVA::_references::MethodCall {
                    target := object JAVA::members::ClassMethod { name := 'variable'; };
                    arguments += object JAVA::_references::IdentifierReference {
                        target := contextVariable;
                    };
                    arguments += object JAVA::_references::StringReference {
                        value := variableName;
                    };
                    arguments += object JAVA::_references::StringReference {
                        value := variableExpr.ownedInit.xmap toExprSingle(variables).toString();
                    };
                };
            };
        };
        localVariables2->add(variable);
    };
    result += self.xmap toValidationCode(expr![LetExp].ownedIn, root, context, variables2, contextVariable, resultVariable, localVariables2);
}

/**
 * Map OCL constraint to the loop:
 *
 *         for (Node context : Helper.iterate(root, "{path}")) {
 *             {validation code}
 *         }
 */
mapping Constraint::toForAll(
    expr : OCLExpression,
    root : OCL::Variable,
    context : OCL::Variable,
    variables : Dict(OCL::Variable, XPATH2::ExprSingle),
    contextVariable : JAVA::_references::ReferenceableElement,
    resultVariable : JAVA::_references::ReferenceableElement,
    localVariables : List(JAVA::_references::ReferenceableElement)) : List(JAVA::statements::Statement)
when { expr.isForAll() }
{
    var contextExpr := expr![IteratorExp].ownedSource;
    result += object JAVA::statements::ForEachLoop {
        var contextParam := object JAVA::parameters::OrdinaryParameter {
            name := 'context';
            typeReference := object JAVA::types::ClassifierReference {
                target := contextVariable.getInterface('org.w3c.dom.Node');
            };
        };
        next := contextParam;
        collection := object JAVA::_references::IdentifierReference {
            target := object JAVA::classifiers::Class { name := 'Helper'; };
            next := object JAVA::_references::MethodCall {
                target := object JAVA::members::ClassMethod { name := 'iterate'; };
                arguments := object JAVA::_references::IdentifierReference {
                    target := contextVariable;
                };
                arguments += object JAVA::_references::StringReference {
                    //var variables : Dict(OCL::Variable, XPATH2::ExprSingle);
                    //log('=== from ' + contextExpr.toString());
                    var variables2 : Dict(OCL::Variable, XPATH2::ExprSingle);//->clone();//.oclAsType(Dict(OCL::Variable, XPATH2::ExprSingle));
                    variables->keys()->forEach (key) {
                    	variables2->put(key, variables->get(key));
                    };
                    variables2->put(root, object PathExpr {
                        step := object RootStepExpr { };
                        step += object SelfStepExpr {
                            step := object AbbrevForwardStep {
                                kind := AbbrevForwardStepKind::child;
                                nodeTest := object QNameTest { name := root.type.getQName() };
                            };
                        };
                    });
                    value := contextExpr.xmap toExprSingle(variables2).toString();
                    //log('=== to   ' + value);
                };
            };
        };
        statement := object JAVA::statements::Block {
            // TODO: This must be refactored. Java variables must be mapped to XPath ones
            /*var nestingLevelsCount := contextExpr.countNestingLevels();
            if (nestingLevelsCount > 0) {
                var path := object PathExpr {
                    step := object SelfStepExpr {
                        step := object AbbrevReverseStep { kind := AbbrevReverseStepKind::parent }
                    };
                    step += Sequence{1..nestingLevelsCount - 1}->collect(
                        object ChildStepExpr {
                            step := object AbbrevReverseStep { kind := AbbrevReverseStepKind::parent }
                        });
                };
                variables2->put(expr.getContext(), path);
            };*/
            // TODO: Refactor it and emptySelf
            // Relative path is better because of non-determenistic Document root, which is sometimes present, sometimes absent
            assert fatal (expr![IteratorExp].ownedIterators->size() = 1);
            var iterator := expr![IteratorExp].ownedIterators->first();
            var variableName := iterator.name.toIdentifier();
            var variables2 := variables;
            variables2->put(iterator, object VarRef { varName := createQName(variableName) });
            
            var localVariables2 := localVariables;
            statements += object JAVA::statements::LocalVariableStatement {
                variable := object JAVA::variables::LocalVariable {
                    name := '__' + variableName;
                    typeReference := contextVariable.getClassReference('com.centreit.repiso.validator.validation.Variable');
                    initialValue := object JAVA::_references::IdentifierReference {
                        target := object JAVA::classifiers::Class { name := 'Helper'; };
                        next := object JAVA::_references::MethodCall {
                            target := object JAVA::members::ClassMethod { name := 'variable'; };
                            arguments += object JAVA::_references::IdentifierReference {
                                target := contextParam;
                            };
                            arguments += object JAVA::_references::StringReference {
                                value := variableName;
                            };
                        };
                    };
                };
                localVariables2->add(variable);
            };
            
            statements += self.xmap toValidationCode(expr![IteratorExp].ownedBody, root, iterator, variables2, contextParam, resultVariable, localVariables);
        };
    };
}

/**
 * Map OCL constraint to the invocation of Helper.check():
 *
 *         result.add(Helper.check(
 *             context,
 *             "{rule XPath expression}",
 *             Arrays.asList({variables list}),
 *             "{error message}",
 *             "{success message}"));
 */
mapping Constraint::toHelperCheckInvocation(
    expr : OCLExpression,
    root : OCL::Variable,
    context : OCL::Variable,
    variables : Dict(OCL::Variable, XPATH2::ExprSingle),
    contextVariable : JAVA::_references::ReferenceableElement,
    resultVariable : JAVA::_references::ReferenceableElement,
    localVariables : List(JAVA::_references::ReferenceableElement)) : List(JAVA::statements::Statement)
{
    result += object JAVA::statements::ExpressionStatement {
    	expression := object JAVA::expressions::AssignmentExpression {
            child := object JAVA::_references::IdentifierReference {
                target := resultVariable;
                next := object JAVA::_references::MethodCall {
                    target := object JAVA::members::ClassMethod { name := 'add'; };
                    arguments := object JAVA::_references::IdentifierReference {
                        target := object JAVA::classifiers::Class { name := 'Helper'; };
                        next := object JAVA::_references::MethodCall {
                            target := object JAVA::members::ClassMethod { name := 'check'; };

                            arguments := object JAVA::_references::IdentifierReference {
                                target := contextVariable;
                            };
                            log('from ' + expr.toString());
                            arguments += object JAVA::_references::StringReference {
                                value := expr/*.xmap replaceSelf(root)*/.xmap toExprSingle(variables).toString();
                                log('to   ' + value);
                            };

                            arguments += object JAVA::_references::IdentifierReference {
                                target := contextVariable.getClass('java.util.Arrays');
                                next := object JAVA::_references::MethodCall {
                                    target := object JAVA::members::ClassMethod { name := 'asList' };
                                    arguments := localVariables->collect(v|
                                        object JAVA::_references::IdentifierReference {
                                            target := v;
                                        });
                                };
                            };

                            var rule := self.xmap toRule();
                            arguments += rule.errorMessage.toMessage(contextVariable, context.type, variables);
                            if (notEmpty(rule.successMessage)) {
                                arguments += rule.successMessage.toMessage(contextVariable, context.type, variables);
                            };
                        };
                    };
                };
            };
        };
    };
}


/*
mapping Constraint::toImplies(
    expr : OCLExpression,
    context : OCL::Variable,
    variables : Dict(OCL::Variable, XPATH2::ExprSingle),
    contextVariable : JAVA::_references::ReferenceableElement,
    resultVariable : JAVA::_references::ReferenceableElement,
    localVariables : List(JAVA::_references::ReferenceableElement)) : List(JAVA::statements::Statement)
when { expr[OperationCallExp].referredOperation->one(isBooleanOperation('implies')) }
{
    var premise := expr![OCL::OperationCallExp].ownedSource;
    var consequent := expr![OCL::OperationCallExp].ownedArguments->first();

    result += object JAVA::statements::Condition {
        condition := object JAVA::_references::IdentifierReference {
            target := object JAVA::classifiers::Class { name := 'Helper'; };
            next := object JAVA::_references::MethodCall {
                target := object JAVA::members::ClassMethod { name := 'evaluate'; };
                arguments += object JAVA::_references::IdentifierReference {
                    target := contextVariable;
                };

            };
        };
    };
            
        premise.xmap toExprSingle(variables)
    };
    
    
     object JAVA::expressions::ConditionalOrExpression {
        children := object JAVA::expressions::UnaryExpression {
            operators := object JAVA::operators::Negate { };
            child := premise.xmap toCheckMethodCall();
        };
        var existsCall := object PathExpr {
            step := object RootStepExpr { };
            step += object AbbrevForwardStep {
                kind := AbbrevForwardStepKind::child;
                nodeTest := object QNameTest { name := consequent[OCL::IteratorExp].ownedIterators->any(true).type.getQName(); };
                var variables : Dict(OCL::Variable, XPATH2::ExprSingle);
                predicate := body.xmap replaceSelf(body).xmap toExprSingle(variables).predicate();
            };
        }.xmap toExistsMethodCall(body);
        if (negateConsequent) {
            children += object JAVA::expressions::UnaryExpression {
                operators := object JAVA::operators::Negate { };
                child := existsCall;
            };
        }
        else {
            children += existsCall;
        };
    };

    result += self.xmap toValidationCode(expr![LetExp].ownedIn, context, variables2, contextVariable, resultVariable, localVariables2);
}
*/
/*
        // TODO: The following logic splits OCL-expression containing allInstances() method
        // into Helper.check() and Helper.exists() invocations.
        // It shouldn't be hardcoded. Something more universal is needed here.
        // The main idea is that all code surrounding allInstances() must be converted into Java code instead of XPath one.
        if (expr[OCL::OperationCallExp]->one(referredOperation.isBooleanOperation('implies'))) {
            var premise := expr![OCL::OperationCallExp].ownedSource;
            var consequent := expr![OCL::OperationCallExp].ownedArguments->any(true);
            var negateConsequent = false;
            if (consequent[OCL::OperationCallExp]->one(referredOperation.isBooleanOperation('not'))) {
                negateConsequent := true;
                consequent := consequent[OCL::OperationCallExp].ownedSource->any(true);
            };
            if (consequent[OCL::IteratorExp]->one(referredIteration.name = 'exists')) {
                var source := consequent[OCL::IteratorExp].ownedSource;
                var body := consequent[OCL::IteratorExp].ownedBody->any(true);
                if (source[OCL::OperationCallExp]->one(referredOperation.name = 'allInstances')) {
                    res := object JAVA::expressions::ConditionalOrExpression {
                        children := object JAVA::expressions::UnaryExpression {
                            operators := object JAVA::operators::Negate { };
                            child := premise.xmap toCheckMethodCall();
                        };
                        var existsCall := object PathExpr {
                            step := object RootStepExpr { };
                            step += object AbbrevForwardStep {
                                kind := AbbrevForwardStepKind::child;
                                nodeTest := object QNameTest { name := consequent[OCL::IteratorExp].ownedIterators->any(true).type.getQName(); };
                                var variables : Dict(OCL::Variable, XPATH2::ExprSingle);
                                predicate := body.xmap replaceSelf(body).xmap toExprSingle(variables).predicate();
                            };
                        }.xmap toExistsMethodCall(body);
                        if (negateConsequent) {
                            children += object JAVA::expressions::UnaryExpression {
                                operators := object JAVA::operators::Negate { };
                                child := existsCall;
                            };
                        }
                        else {
                            children += existsCall;
                        };
                    };
                }
                else {
                    res := expr.xmap toCheckMethodCall();
                };
            }
            else {
                res := expr.xmap toCheckMethodCall();
            };
        }
        else {
            res := expr.xmap toCheckMethodCall();
        }
*/


/**
 * Converts string of the form
 *   Some text {{ocl expression 1}}, more text {{ocl expression 2}}...
 * to
 *   Helper.format(context, "Some text %s, more text %s...", "{XPath expression 1}", ...),
 */
query String::toMessage(
    contextVariable : JAVA::_references::ReferenceableElement,
    context : OCL::Type,
    variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : JAVA::_references::IdentifierReference
{
    var str := '';
    var args : List(String);
    try {
        // TODO: Ugly hack, refactor it
        //if (variables->notEmpty()) {
        //    emptySelf := true;
        //};
        self.tokenizeDocOCL()->forEach (token) {
            if (token.isExpr) {
                str := str + '%s';
                args += token.text.toExpressionInOCL(context).ownedBody.xmap toExprSingle(variables).toString();
            }
            else {
                str := str + token.text;
            };
        };
    }
    except () {
        //emptySelf := false;
    };
    //emptySelf := false;
	
    return object JAVA::_references::IdentifierReference {
        target := contextVariable.getClass('com.centreit.repiso.validator.validation.Helper');
        next := object JAVA::_references::MethodCall {
            target := object JAVA::members::ClassMethod { name := 'format'; };
            arguments := object JAVA::_references::IdentifierReference {
                target := contextVariable;
            };
            arguments += object JAVA::_references::StringReference {
                value := str;
            };
            args->forEach (arg) {
                arguments += object JAVA::_references::StringReference {
                    value := arg;
                };
            };
        };
    };
}
/*
mapping OCLExpression::toCheckMethodCall() : JAVA::_references::IdentifierReference
{
    target := object JAVA::classifiers::Class {
        name := 'Helper';
    };
    next := object JAVA::_references::MethodCall {
        target := object JAVA::members::ClassMethod { name := 'check'; };
        arguments := object JAVA::_references::IdentifierReference {
            target := object JAVA::members::Field { name := 'message'; };
        };
        var variables : Dict(OCL::Variable, XPATH2::ExprSingle);
        arguments += object JAVA::_references::StringReference { value := self.xmap toExprSingle(variables).toString(); };
    };
}
*/
mapping OCLExpression::replaceSelf(variable : OCL::Variable) : OCLExpression
disjuncts
    PropertyCallExp::replaceSelf,
    OperationCallExp::replaceSelf
{
}

mapping PropertyCallExp::replaceSelf(variable : OCL::Variable) : OCLExpression
{
    init {
        //log(self.isBasedOnSelf().repr() + ' ' + self.isRelatedToSelf().repr() + ' ' + self.repr());
        if (self.isBasedOnSelf()) {
            //var id = 'param' + getSeqNumber().toString();
            //var paramSet := if params->hasKey(expr) then params->get(expr) else object Set(Param) { } endif;
            //paramSet += object Param { name := id; xpath := self.deepclone().oclAsType(PropertyCallExp); };
            //params->put(expr, paramSet);
            //result := object StringLiteralExp { stringSymbol := ':' + id };
            result := object VariableExp {
                referredVariable := variable;
            };
    	}
    	else {
            result := self.deepclone().oclAsType(PropertyCallExp);
    	};
    }
}

// TODO: Всё это неправильно, видимо нужно найти VariableExp для self и заменить его на какую-то явную переменную
// А лучше вообще не модифицировать OCL, а учесть эту логику при преобразовании в XPath
mapping OperationCallExp::replaceSelf(variable : OCL::Variable) : OCLExpression
{
    init {
        if (self.isBasedOnSelf()) {
            //var id = 'param' + getSeqNumber().toString();
            //var paramSet := if params->hasKey(expr) then params->get(expr) else object Set(Param) { } endif;
            //paramSet += object Param { name := id; xpath := self.deepclone().oclAsType(OperationCallExp); };
            //params->put(expr, paramSet);
            //result := object StringLiteralExp { stringSymbol := ':' + id };
            result := object VariableExp {
                referredVariable := variable;
            };
        }
        elif (not(self.isRelatedToSelf())) {
            result := self.deepclone().oclAsType(OperationCallExp);
        }
        else {
            var op := self.deepclone().oclAsType(OperationCallExp);
            object op : OperationCallExp {
            	ownedSource := self.ownedSource.xmap replaceSelf(variable);
            	ownedArguments := self.ownedArguments->replaceSelf(variable);
            };
            result := op;
        };
    }
}
/*
mapping ExprSingle::toExistsMethodCall(expr : OCLExpression) : JAVA::_references::IdentifierReference
{
    target := object JAVA::classifiers::Class {
        name := 'Helper';
    };
    next := object JAVA::_references::MethodCall {
        target := object JAVA::members::ClassMethod { name := 'exists'; };
        var xpath := self.toString();
        arguments := object JAVA::_references::IdentifierReference {
            target := object JAVA::members::Field { name := 'message'; };
        };
        arguments += object JAVA::_references::StringReference { value := xpath.replaceAll("'(:param\\d+)'", "$1"); };
        arguments += object JAVA::_references::IdentifierReference {
            target := object JAVA::classifiers::Class { name := 'Arrays'; };
            next := object JAVA::_references::MethodCall {
                target := object JAVA::members::ClassMethod {
                    name := 'asList';
                };
                arguments := params->get(expr)->sortedBy(name)->toNewConstructorCall();
            };
        };
    };
}

mapping Param::toNewConstructorCall() : JAVA::instantiations::NewConstructorCall
{
    typeReference := object JAVA::types::ClassifierReference {
        target := object JAVA::classifiers::Class {
            name := 'XPathParam';
        };
    };
    arguments := object JAVA::_references::StringReference {
        value := self.name;
    };
    var variables : Dict(OCL::Variable, XPATH2::ExprSingle);
    arguments += object JAVA::_references::StringReference {
        value := self.xpath.xmap toExprSingle(variables).toString();
    };
    arguments += object JAVA::_references::IdentifierReference {
        target := object JAVA::classifiers::Class {
        	name := self.xpath.getType();
        };
        next := object JAVA::_references::ReflectiveClassReference { };
    };
}
*/
///////////////////////////////////////////////////////////////////////////////
// Helpers

//query String::quoteJavaName() : String =
//    self.replaceAll('[^A-Za-z0-9]', '_');
/*
query OCLExpression::getType() : String
{
    if (self.oclIsKindOf(OperationCallExp)) {
        return self.oclAsType(OperationCallExp).type.getType();
    }
    elif (self.oclIsKindOf(PropertyCallExp)) {
        return  self.oclAsType(PropertyCallExp).type.getType();
    };
    raise IllegalArgumentException('Unable to determine type of ' + self.repr());
    return null;
}

query OCL::Type::getType() : String
{
    // TODO: Something more adequate is needed here
    if (self.name = 'Integer') {
        return 'Integer';
    }
    elif (self.oclIsKindOf(OCL::NamedElement)) {
        if (self.oclAsType(OCL::NamedElement).getETarget().is('String')) {
            return 'String';
        };
    };
    raise IllegalArgumentException('Unknown data type ' + self.metaClassName() + ' ' + self.repr() + ' ' + self.oclIsKindOf(OCL::Element).repr());
    return null;
}
*/
query OCLExpression::isRelatedToSelf() : Boolean =
    if self.oclIsKindOf(PropertyCallExp) then self![PropertyCallExp].ownedSource.isRelatedToSelf()
    elif self.oclIsKindOf(OperationCallExp) then self![OperationCallExp]->forAll(ownedSource.isRelatedToSelf() or ownedArguments->forAll(isRelatedToSelf()))
    else self.oclIsKindOf(VariableExp) and self![VariableExp].referredVariable.name = 'self' endif;

query OCLExpression::isBasedOnSelf() : Boolean =
    if self.oclIsKindOf(PropertyCallExp) then self![PropertyCallExp].ownedSource.isBasedOnSelf()
    elif self.oclIsKindOf(OperationCallExp) then self![OperationCallExp]->forAll(ownedSource.isBasedOnSelf() and ownedArguments->forAll(isBasedOnSelf()))
    else self.oclIsKindOf(VariableExp) and self![VariableExp].referredVariable.name = 'self' endif;


// TODO: It's a bad idea to count levels.
// It's better to declare an XPath variables for Java variables and to use variable resolver
/*
query OCLExpression::countNestingLevels() : Integer
{
    var message := 'ERROR: Unable to count nesting levels for ' + self.metaClassName();
    log(message);
    raise Exception(message);
    return null;
}

query PropertyCallExp::countNestingLevels() : Integer =
    self.ownedSource.countNestingLevels() + 1;

query VariableExp::countNestingLevels() : Integer = 1;

query IteratorExp::countNestingLevels() : Integer
{
    if (self.referredIteration.name = 'select') {
        return self.ownedSource.countNestingLevels();
    }
    else {
        var message := 'ERROR: Unable to count nesting levels for ' + self.metaClassName();
        log(message);
        raise Exception(message);
    };
    return null;
}
*/
