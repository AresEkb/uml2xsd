/**
 * Copyright (c) 2015, 2016 Denis Nikiforov.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *    Denis Nikiforov - initial API and implementation
 */
 
import uml2xsd.UtilitiesLibrary;
import ISO20022Helpers;
import JavaHelpers;
import OCLtoXPath;
import DocOCL;

modeltype UML uses 'http://www.eclipse.org/uml2/2.1.0/UML';
modeltype OCL 'strict' uses 'http://www.eclipse.org/ocl/2015/Pivot';
modeltype JAVA uses 'http://www.emftext.org/java';
modeltype ECORE uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype TYPE uses 'http://www.eclipse.org/emf/2003/XMLType';
modeltype XPATH2 'strict' uses 'http://www.emftext.org/language/xpath2';

transformation ISO20022toJava(in m : UML, out j : JAVA);

exception IllegalArgumentException { }

intermediate class Param { name : String; xpath : OCLExpression; type : String };

property params : Dict(OCLExpression, Set(Param));

/**
 * Find all message definitions and map them to compilation units
 */
main()
{
    useFunctionQNames := true;
    emptySelf := true;
    m.objectsOfKind(Classifier)->select(is('MessageDefinition'))->toCompilationUnit();
}

/**
 * Map a message definition to the following compilation unit:
 *
 * package com.centreit.repiso.ocl.validator.validation;
 *
 * import ... 
 *
 * @Generated("uml2xsd")
 * public class {name} extends BaseValidator {
 *     private Node root;
 *
 *     public void init(String message) {
 *         this.root = Helper.parse(message, "/ Document / {root element name}");
 *     }
 *
 *     {validation methods}
 * }
 *
 */
mapping Classifier::toCompilationUnit() : JAVA::containers::CompilationUnit
{
    var className := self.name.quoteJavaName();
    log('  Found message ' + self.name);

    name := self.name;
    namespaces := 'com.centreit.repiso.ocl.validator.validation'.tokenize('.');

    addClassImport(result, 'java.util.ArrayList');
    addInterfaceImport(result, 'java.util.List');
    addAnnotationImport(result, 'javax.annotation.Generated');
    addInterfaceImport(result, 'org.w3c.dom.Node');
    addClassImport(result, 'com.centreit.repiso.ocl.validator.validation.BaseValidator');
    addClassImport(result, 'com.centreit.repiso.ocl.validator.validation.Helper');
    addClassImport(result, 'com.centreit.repiso.ocl.validator.validation.Result');

    classifiers := object JAVA::classifiers::Class {
        name := className;
        
        _extends := result.getClassReference('com.centreit.repiso.ocl.validator.validation.BaseValidator');
        
        annotationsAndModifiers += object JAVA::annotations::AnnotationInstance {
            annotation := result.getAnnotation('javax.annotation.Generated');
            parameter := object JAVA::annotations::SingleAnnotationParameter {
            	value := object JAVA::_references::StringReference { value := 'uml2xsd'; };
            };
        };
        annotationsAndModifiers += object JAVA::modifiers::Public { };

        var rootField := object JAVA::members::Field {
            name := 'root';
            typeReference := result.getClassReference('org.w3c.dom.Node');
            annotationsAndModifiers := object JAVA::modifiers::Private { };
        };

        members += rootField;
        
        members += object JAVA::members::ClassMethod {
            name := "init";
            typeReference := object JAVA::types::_Void { };
            parameters := object JAVA::parameters::OrdinaryParameter {
            	name := 'message';
            	typeReference := object JAVA::types::ClassifierReference {
                    target := result.getClass('java.lang.String');
            	};
            };
            annotationsAndModifiers := object JAVA::modifiers::Public { };
            statements := object JAVA::statements::ExpressionStatement {
            	expression := object JAVA::expressions::AssignmentExpression {
            		child := object JAVA::_references::IdentifierReference {
                        target := rootField;
            		};
            		assignmentOperator := object JAVA::operators::Assignment { };
            		value := object JAVA::_references::IdentifierReference {
            			target := object JAVA::classifiers::Class { name := 'Helper'; };
            			next := object JAVA::_references::MethodCall {
                            target := object JAVA::members::ClassMethod { name := 'parse'; };
                            arguments := object JAVA::_references::IdentifierReference {
                                target := object JAVA::members::Field { name := 'message'; };
                            };
                            arguments += object JAVA::_references::StringReference {
                                value := self.getRootPath().toString();
                            };
            			};
            		};
            	};
            };
        };

        members += self.ownedRule->sortedBy(name)->toValidationMethod(rootField);
    };
}

/**
 * Map OCL constraint to the following validation method:
 *
 *     @RuleMetadata(id = "{rule id}",
 *                   description = "{rule description}",
 *                   ocl = "{rule OCL}")
 *     public void check{rule name}(List<Result> results) {
 *         {validation code}
 *     }
 *
 */
mapping Constraint::toValidationMethod(rootField : JAVA::members::Field) : JAVA::members::ClassMethod
{
    log('    Found rule ' + self.name);
    name := 'check' + self.name.quoteJavaName().capitalize();

    annotationsAndModifiers += object JAVA::annotations::AnnotationInstance {
        annotation := result.getClass('com.centreit.repiso.ocl.validator.validation.RuleMetadata');
        parameter := object JAVA::annotations::AnnotationParameterList {
            // TODO: The following logic must be moved to Helper and reused in the XSLT generator
            var doc := self.ownedComment.body->any(true).cleanML().tokenize(Set { '\n\n' });
            assert fatal (doc->size() >= 2 and doc->size() <= 3)
                with log('Constraint\' documentation must contain 2 or 3 sections:\n' +
                    self.ownedComment.body->any(true));

            settings += object JAVA::annotations::AnnotationAttributeSetting {
                attribute := object JAVA::members::InterfaceMethod { name := 'id' };
                value := object JAVA::_references::StringReference { value := self.name };
            };
            settings += object JAVA::annotations::AnnotationAttributeSetting {
                attribute := object JAVA::members::InterfaceMethod { name := 'description' };
                value := object JAVA::_references::StringReference { value := doc->at(1) };
            };
            settings += object JAVA::annotations::AnnotationAttributeSetting {
                attribute := object JAVA::members::InterfaceMethod { name := 'ocl' };
                value := object JAVA::_references::StringReference { value := self.specification[OpaqueExpression].body->any(true).replace('\r\n', '\n') };
            };
        };
    };
    annotationsAndModifiers += object JAVA::modifiers::Public { };

    var resultParam := object JAVA::parameters::OrdinaryParameter {
        name := 'results';
        typeReference := object JAVA::types::ClassifierReference {
            target := result.getInterface('java.util.List');
            typeArguments := object JAVA::generics::QualifiedTypeArgument {
                typeReference := result.getClassReference('com.centreit.repiso.ocl.validator.validation.Result');
            };
        };
    };
    
    typeReference := object JAVA::types::Void { };
    parameters := resultParam;
    
    try {
        statements := self.xmap toValidationCode(self.toExpressionInOCL().ownedBody, rootField, resultParam);
    }
    except () {
        log('WARNING: Unable to generate validation code');
    };
    // This code can't be moved into exception handling section, because it seems that sometimes exceptions aren't raised 
    if (statements->isEmpty()) {
        statements += object JAVA::statements::Throw {
            throwable := object JAVA::instantiations::NewConstructorCall {
                typeReference := result.getClassReference('java.lang.UnsupportedOperationException');
            };
        };
    };
}

mapping Constraint::toValidationCode(
    expr : OCLExpression,
    contextVariable : JAVA::_references::ReferenceableElement,
    resultVariable : JAVA::_references::ReferenceableElement) : List(JAVA::statements::Statement)
disjuncts
    Constraint::toForAll,
    Constraint::toHelperValidateInvocation
{
}

 
/*
        // TODO: The following logic splits OCL-expression containing allInstances() method
        // into Helper.check() and Helper.exists() invocations.
        // It shouldn't be hardcoded. Something more universal is needed here.
        // The main idea is that all code surrounding allInstances() must be converted into Java code instead of XPath one.
        if (expr[OCL::OperationCallExp]->one(referredOperation.isBooleanOperation('implies'))) {
            var premise := expr![OCL::OperationCallExp].ownedSource;
            var consequent := expr![OCL::OperationCallExp].ownedArguments->any(true);
            var negateConsequent = false;
            if (consequent[OCL::OperationCallExp]->one(referredOperation.isBooleanOperation('not'))) {
                negateConsequent := true;
                consequent := consequent[OCL::OperationCallExp].ownedSource->any(true);
            };
            if (consequent[OCL::IteratorExp]->one(referredIteration.name = 'exists')) {
                var source := consequent[OCL::IteratorExp].ownedSource;
                var body := consequent[OCL::IteratorExp].ownedBody->any(true);
                if (source[OCL::OperationCallExp]->one(referredOperation.name = 'allInstances')) {
                    res := object JAVA::expressions::ConditionalOrExpression {
                        children := object JAVA::expressions::UnaryExpression {
                            operators := object JAVA::operators::Negate { };
                            child := premise.xmap toCheckMethodCall();
                        };
                        var existsCall := object PathExpr {
                            step := object RootStepExpr { };
                            step += object AbbrevForwardStep {
                                kind := AbbrevForwardStepKind::child;
                                nodeTest := object QNameTest { name := consequent[OCL::IteratorExp].ownedIterators->any(true).type.getQName(); };
                                var variables : Dict(OCL::Variable, XPATH2::ExprSingle);
                                predicate := body.xmap replaceSelf(body).xmap toExprSingle(variables).predicate();
                            };
                        }.xmap toExistsMethodCall(body);
                        if (negateConsequent) {
                            children += object JAVA::expressions::UnaryExpression {
                                operators := object JAVA::operators::Negate { };
                                child := existsCall;
                            };
                        }
                        else {
                            children += existsCall;
                        };
                    };
                }
                else {
                    res := expr.xmap toCheckMethodCall();
                };
            }
            else {
                res := expr.xmap toCheckMethodCall();
            };
        }
        else {
            res := expr.xmap toCheckMethodCall();
        }*/

 
/**
 * Map OCL constraint to the loop:
 *
 *         for (Node context : Helper.iterate(root, "{path}")) {
 *             {validation code}
 *         }
 */
mapping Constraint::toForAll(
    expr : OCLExpression,
    contextVariable : JAVA::_references::ReferenceableElement,
    resultVariable : JAVA::_references::ReferenceableElement) : List(JAVA::statements::Statement)
when { expr.isForAll() }
{
    result += object JAVA::statements::ForEachLoop {
        var contextParam := object JAVA::parameters::OrdinaryParameter {
            name := 'context';
            typeReference := object JAVA::types::ClassifierReference {
                target := contextVariable.getInterface('org.w3c.dom.Node');
            };
        };
        next := contextParam;
        collection := object JAVA::_references::IdentifierReference {
            target := object JAVA::classifiers::Class { name := 'Helper'; };
            next := object JAVA::_references::MethodCall {
                target := object JAVA::members::ClassMethod { name := 'iterate'; };
                arguments := object JAVA::_references::IdentifierReference {
                    target := contextVariable;
                };
                arguments += object JAVA::_references::StringReference {
                    var variables : Dict(OCL::Variable, XPATH2::ExprSingle);
                    value := expr![IteratorExp].ownedSource.xmap toExprSingle(variables).toString();
                };
            };
        };
        statement := object JAVA::statements::Block {
            statements += self.xmap toValidationCode(expr![IteratorExp].ownedBody, contextParam, resultVariable);
        };
    };
}

/**
 * Map OCL constraint to the invocation of Helper.validate():
 *
 *         result.add(Helper.validate(
 *             context,
 *             "{rule XPath expression}",
 *             "{error message}",
 *             "{valid message}"));
 */
mapping Constraint::toHelperValidateInvocation(
    expr : OCLExpression,
    contextVariable : JAVA::_references::ReferenceableElement,
    resultVariable : JAVA::_references::ReferenceableElement) : List(JAVA::statements::Statement)
{
    var variables : Dict(OCL::Variable, XPATH2::ExprSingle);
    result += object JAVA::statements::ExpressionStatement {
    	expression := object JAVA::expressions::AssignmentExpression {
            child := object JAVA::_references::IdentifierReference {
                target := resultVariable;
                next := object JAVA::_references::MethodCall {
                    target := object JAVA::members::ClassMethod { name := 'add'; };
                    arguments := object JAVA::_references::IdentifierReference {
                        target := object JAVA::classifiers::Class { name := 'Helper'; };
                        next := object JAVA::_references::MethodCall {
                            target := object JAVA::members::ClassMethod { name := 'validate'; };
                            
                            arguments := object JAVA::_references::IdentifierReference {
                                target := contextVariable;
                            };
                            arguments += object JAVA::_references::StringReference {
                                value := expr.xmap toExprSingle(variables).toString();
                            };
    
                            // TODO: The following logic must be moved to Helper and reused in the XSLT generator
                            var doc := self.ownedComment.body->any(true).cleanML().tokenize(Set { '\n\n' });
                            assert fatal (doc->size() >= 2 and doc->size() <= 3)
                                with log('Constraint\' documentation must contain 2 or 3 sections:\n' +
                                    self.ownedComment.body->any(true));
    
                            arguments += doc->at(2).toMessage(contextVariable, expr.getContext(), variables);
                            if (doc->size() >= 3) {
                                arguments += doc->at(3).toMessage(contextVariable, expr.getContext(), variables);
                            };
                        };
                    };
                };
            };
        };
    };
}

/**
 * Converts string of the form
 *   Some text {{ocl expression 1}}, more text {{ocl expression 2}}...
 * to
 *   Helper.format(context, "Some text %s, more text %s...", "{XPath expression 1}", ...),
 */
query String::toMessage(contextVariable : JAVA::_references::ReferenceableElement, context : OCL::Type, variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : JAVA::_references::IdentifierReference
{
    var str := '';
    var args : List(String);
    self.tokenizeDocOCL()->forEach (token) {
        if (token.isExpr) {
            str := str + '%s';
            args += token.text.toExpressionInOCL(context).ownedBody.xmap toExprSingle(variables).toString();
        }
        else {
            str := str + token.text;
        };
    };
    return object JAVA::_references::IdentifierReference {
        target := contextVariable.getClass('com.centreit.repiso.ocl.validator.validation.Helper');
        next := object JAVA::_references::MethodCall {
            target := object JAVA::members::ClassMethod { name := 'format'; };
            arguments := object JAVA::_references::IdentifierReference {
                target := contextVariable;
            };
            arguments += object JAVA::_references::StringReference {
                value := str;
            };
            args->forEach (arg) {
                arguments += object JAVA::_references::StringReference {
                    value := arg;
                };
            };
        };
    };
}






mapping OCLExpression::toCheckMethodCall() : JAVA::_references::IdentifierReference
{
    target := object JAVA::classifiers::Class {
        name := 'Helper';
    };
    next := object JAVA::_references::MethodCall {
        target := object JAVA::members::ClassMethod { name := 'check'; };
        arguments := object JAVA::_references::IdentifierReference {
            target := object JAVA::members::Field { name := 'message'; };
        };
        var variables : Dict(OCL::Variable, XPATH2::ExprSingle);
        arguments += object JAVA::_references::StringReference { value := self.xmap toExprSingle(variables).toString(); };
    };
}

mapping OCLExpression::replaceSelf(expr : OCLExpression) : OCLExpression
disjuncts
    PropertyCallExp::replaceSelf,
    OperationCallExp::replaceSelf
{
}

mapping PropertyCallExp::replaceSelf(expr : OCLExpression) : OCLExpression
{
    init {
        //log(self.isBasedOnSelf().repr() + ' ' + self.isRelatedToSelf().repr() + ' ' + self.repr());
        if (self.isBasedOnSelf()) {
            var id = 'param' + getSeqNumber().toString();
            var paramSet := if params->hasKey(expr) then params->get(expr) else object Set(Param) { } endif;
            paramSet += object Param { name := id; xpath := self.deepclone().oclAsType(PropertyCallExp); };
            params->put(expr, paramSet);
            result := object StringLiteralExp { stringSymbol := ':' + id };
    	}
    	else {
            result := self.deepclone().oclAsType(PropertyCallExp);
    	};
    }
}

mapping OperationCallExp::replaceSelf(expr : OCLExpression) : OCLExpression
{
    init {
        if (self.isBasedOnSelf()) {
            var id = 'param' + getSeqNumber().toString();
            var paramSet := if params->hasKey(expr) then params->get(expr) else object Set(Param) { } endif;
            paramSet += object Param { name := id; xpath := self.deepclone().oclAsType(OperationCallExp); };
            params->put(expr, paramSet);
            result := object StringLiteralExp { stringSymbol := ':' + id };
        }
        elif (not(self.isRelatedToSelf())) {
            result := self.deepclone().oclAsType(OperationCallExp);
        }
        else {
            var op := self.deepclone().oclAsType(OperationCallExp);
            object op : OperationCallExp {
            	ownedSource := self.ownedSource.xmap replaceSelf(expr);
            	ownedArguments := self.ownedArguments->replaceSelf(expr);
            };
            result := op;
        };
    }
}

mapping ExprSingle::toExistsMethodCall(expr : OCLExpression) : JAVA::_references::IdentifierReference
{
    target := object JAVA::classifiers::Class {
        name := 'Helper';
    };
    next := object JAVA::_references::MethodCall {
        target := object JAVA::members::ClassMethod { name := 'exists'; };
        var xpath := self.toString();
        arguments := object JAVA::_references::IdentifierReference {
            target := object JAVA::members::Field { name := 'message'; };
        };
        arguments += object JAVA::_references::StringReference { value := xpath.replaceAll("'(:param\\d+)'", "$1"); };
        arguments += object JAVA::_references::IdentifierReference {
            target := object JAVA::classifiers::Class { name := 'Arrays'; };
            next := object JAVA::_references::MethodCall {
                target := object JAVA::members::ClassMethod {
                    name := 'asList';
                };
                arguments := params->get(expr)->sortedBy(name)->toNewConstructorCall();
            };
        };
    };
}

mapping Param::toNewConstructorCall() : JAVA::instantiations::NewConstructorCall
{
    typeReference := object JAVA::types::ClassifierReference {
        target := object JAVA::classifiers::Class {
            name := 'XPathParam';
        };
    };
    arguments := object JAVA::_references::StringReference {
        value := self.name;
    };
    var variables : Dict(OCL::Variable, XPATH2::ExprSingle);
    arguments += object JAVA::_references::StringReference {
        value := self.xpath.xmap toExprSingle(variables).toString();
    };
    arguments += object JAVA::_references::IdentifierReference {
        target := object JAVA::classifiers::Class {
        	name := self.xpath.getType();
        };
        next := object JAVA::_references::ReflectiveClassReference { };
    };
}

///////////////////////////////////////////////////////////////////////////////
// Helpers

query String::quoteJavaName() : String =
    self.replaceAll('[^A-Za-z0-9]', '_');

query OCLExpression::getType() : String
{
    if (self.oclIsKindOf(OperationCallExp)) {
        return self.oclAsType(OperationCallExp).type.getType();
    }
    elif (self.oclIsKindOf(PropertyCallExp)) {
        return  self.oclAsType(PropertyCallExp).type.getType();
    };
    raise IllegalArgumentException('Unable to determine type of ' + self.repr());
    return null;
}

query OCL::Type::getType() : String
{
    // TODO: Something more adequate is needed here
    if (self.name = 'Integer') {
        return 'Integer';
    }
    elif (self.oclIsKindOf(OCL::NamedElement)) {
        if (self.oclAsType(OCL::NamedElement).getETarget().is('String')) {
            return 'String';
        };
    };
    raise IllegalArgumentException('Unknown data type ' + self.metaClassName() + ' ' + self.repr() + ' ' + self.oclIsKindOf(OCL::Element).repr());
    return null; 
}

query OCLExpression::isRelatedToSelf() : Boolean =
    if self.oclIsKindOf(PropertyCallExp) then self![PropertyCallExp].ownedSource.isRelatedToSelf()
    elif self.oclIsKindOf(OperationCallExp) then self![OperationCallExp]->forAll(ownedSource.isRelatedToSelf() or ownedArguments->forAll(isRelatedToSelf())) 
    else self.oclIsKindOf(VariableExp) and self![VariableExp].referredVariable.name = 'self' endif;

query OCLExpression::isBasedOnSelf() : Boolean =
    if self.oclIsKindOf(PropertyCallExp) then self![PropertyCallExp].ownedSource.isBasedOnSelf()
    elif self.oclIsKindOf(OperationCallExp) then self![OperationCallExp]->forAll(ownedSource.isBasedOnSelf() and ownedArguments->forAll(isBasedOnSelf())) 
    else self.oclIsKindOf(VariableExp) and self![VariableExp].referredVariable.name = 'self' endif;
