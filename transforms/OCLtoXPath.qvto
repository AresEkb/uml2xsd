/**
 * Copyright (c) 2013, 2015 Denis Nikiforov.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *    Denis Nikiforov - initial API and implementation
 */

// There are some XPath AST simplifications in the code.
// It would be great to separate them from the transformation,
// but the problem is that simplification mapping should traverse
// whole AST and therefore it will be even more complex than an
// OCL to XPath transformation itself.

import uml2xsd.UtilitiesLibrary;
import Helpers;

modeltype OCL 'strict' uses 'http://www.eclipse.org/ocl/2015/Pivot';
modeltype XPATH2 'strict' uses 'http://www.emftext.org/language/xpath2';
modeltype TYPE uses 'http://www.eclipse.org/emf/2003/XMLType';

library OCLtoXPath;

property useFunctionQNames : Boolean = true;

mapping ExpressionInOCL::toXPath() : Expr
{
    log('    Transforming OCL expression\n      ' + self.body.replaceAll('\n', '\n      '));
    expr := self.ownedBody.xmap toExprSingle();
    log('    to\n      ' + result.toString());
}

query ExpressionInOCL::toExprSingle() : ExprSingle
{
    log('    Transforming OCL expression\n      ' + self.body.replaceAll('\n', '\n      '));
    var expr := self.ownedBody.xmap toExprSingle();
    log('    to\n      ' + expr.toString());
    return expr;
}

mapping OCLExpression::toExprSingle() : ExprSingle
disjuncts
    // Logic
    OperationCallExp::toOrExpr,
    OperationCallExp::toAndExpr,
    OperationCallExp::toImplies,
    OperationCallExp::toNotExpr,
    IteratorExp::toExists,
    IteratorExp::toForAll,
    // Comparision
    OperationCallExp::toLeftNotNull,
    OperationCallExp::toRightNotNull,
    OperationCallExp::toComparisonExpr,
    // Arithmetic
    OperationCallExp::toAdditiveExpr,
    OperationCallExp::toMultiplicativeExpr,
    // Path
    PropertyCallExp::toPathExpr,
    // Functions
    OperationCallExp::asSet,
    OperationCallExp::toCountFunctionCall,
    OperationCallExp::toStringLengthFunctionCall,
    OperationCallExp::toIsEmpty,
    OperationCallExp::toNotEmpty,
    OperationCallExp::toSumFunctionCall,
    IteratorExp::isUnique,
    // Literals
    IntegerLiteralExp::toLiteral,
    UnlimitedNaturalLiteralExp::toLiteral,
    RealLiteralExp::toLiteral,
    StringLiteralExp::toLiteral,
    BooleanLiteralExp::toLiteral,
    // Unknown expressions
    OCLExpression::riseError
{}

//////////////////////////////////////////////////////////////////////////////
// Logic

mapping OperationCallExp::toOrExpr() : ExprSingle
when { self.referredOperation.isBooleanOperation('or') }
{
    init {
        result := self.ownedSource.xmap toExprSingle().orExpr(
            self.ownedArguments->first().xmap toExprSingle());
    }
}

mapping OperationCallExp::toAndExpr() : AndExpr
when { self.referredOperation.isBooleanOperation('and') }
{
    operand := self.ownedSource.xmap toExprSingle().andExprOperand();
    operand += self.ownedArguments->first().xmap toExprSingle().andExprOperand();
}

mapping OperationCallExp::toImplies() : ExprSingle
when { self.referredOperation.isBooleanOperation('implies') }
{
    init {
        result := self.ownedSource.xmap toExprSingle().notExpr().orExpr(
            self.ownedArguments->first().xmap toExprSingle());
    }
}

mapping OperationCallExp::toNotExpr() : ExprSingle
when { self.referredOperation.isBooleanOperation('not') }
{
    init {
        result := self.ownedSource.xmap toExprSingle().notExpr();
    }
}

mapping IteratorExp::toExists() : FunctionCall
when { self.referredIteration.name = 'exists' }
{
    init {
        result := self.ownedSource.xmap toPathExpr(self.ownedBody.xmap toExprSingle()).booleanExpr();
    }
}

mapping IteratorExp::toForAll() : ExprSingle
when { self.referredIteration.name = 'forAll' }
{
    init {
        result := self.ownedSource.xmap toPathExpr(self.ownedBody.xmap toExprSingle().notExpr()).notExpr();
    }
}

query ExprSingle::booleanExpr() : FunctionCall = object FunctionCall { name := 'boolean'.createFunctionQName(); arg := self; };

query ExprSingle::notExpr() : ExprSingle =
    // Simplification: fn:not(fn:not(...)) = fn:boolean(...)
    if self.isFunctionCall('not'.createFunctionQName()) then
        self.oclAsType(FunctionCall).arg->collectOne(booleanExpr())
    // Simplification: fn:not(fn:not(...) and fn:not(...) and ...) = (... or ... or ...)
    elif self.oclIsKindOf(AndExpr) and self.oclAsType(AndExpr).operand->forAll(isFunctionCall('not'.createFunctionQName())) then
        object OrExpr { operand :=
            self.oclAsType(AndExpr).operand->collect(
                oclAsType(FunctionCall).arg->first().orExprOperand()) }
    // Simplification: fn:not(fn:not(...) or fn:not(...) or ...) = (... and ... and ...)
    elif self.oclIsKindOf(OrExpr) and self.oclAsType(OrExpr).operand->forAll(isFunctionCall('not'.createFunctionQName())) then
        object AndExpr { operand :=
            self.oclAsType(OrExpr).operand->collect(
                oclAsType(FunctionCall).arg->first().andExprOperand()) }
    else
        object FunctionCall { name := 'not'.createFunctionQName(); arg := self; }
    endif;

query ExprSingle::orExpr(rhs : ExprSingle) : ExprSingle
{
    var operands := self.orExprOperand();
    operands += rhs.orExprOperand();
    return 
    // Simplification: fn:not(...) or fn:not(...) = fn:not(... and ...)
    if operands->forAll(isFunctionCall('not'.createFunctionQName())) then
        object AndExpr { operand :=
            operands->collect(
                oclAsType(FunctionCall).arg->first().andExprOperand()) }.notExpr()
    else
        object OrExpr { operand := operands }
    endif;
}

query ExprSingle::orExprOperand() : OrderedSet(OrExprChild) =
    // Simplification: (... or ...) or ... = ... or ... or ...
    if self.oclIsKindOf(OrExpr) then
        self.oclAsType(OrExpr).operand
    // Simplification: fn:boolean(...) or ... = ... or ...
    elif self.isFunctionCall('boolean'.createFunctionQName()) then
        self.oclAsType(FunctionCall).arg
    // Simplification: (...) or ... = ... or ...
    elif self.oclIsKindOf(OrExprChild) then
        self.oclAsType(OrExprChild)->asOrderedSet()
    else
        object ParenthesizedExpr { expr := self }->asOrderedSet()
    endif;

query ExprSingle::andExprOperand() : OrderedSet(AndExprChild) =
    // Simplification: (... and ...) and ... = ... and ... and ...
    if self.oclIsKindOf(AndExpr) then
        self.oclAsType(AndExpr).operand
    // Simplification: fn:boolean(...) and ... = ... and ...
    elif self.isFunctionCall('boolean'.createFunctionQName()) then
        self.oclAsType(FunctionCall).arg
    // Simplification: (...) and ... = ... and ...
    elif self.oclIsKindOf(AndExprChild) then
        self.oclAsType(AndExprChild)->asOrderedSet()
    else
        object ParenthesizedExpr { expr := self }->asOrderedSet()
    endif;

//////////////////////////////////////////////////////////////////////////////
// Comparision

mapping OperationCallExp::toLeftNotNull() : ExprSingle
when { self.name = '<>' and self.ownedArguments->isNullLiteralExp() }
{
    init {
        result := self.ownedSource.xmap toExprSingle();
    }
}

mapping OperationCallExp::toRightNotNull() : ExprSingle
when { self.name = '<>' and self.ownedSource.isNullLiteralExp() }
{
    init {
        result := self.ownedArguments->first().xmap toExprSingle();
    }
}

mapping OperationCallExp::toComparisonExpr() : ComparisonExpr
when { self.name.toGeneralComp() <> null and not(self.ownedSource.isNullLiteralExp() or self.ownedArguments->isNullLiteralExp()) }
{
    left := self.ownedSource.xmap toExprSingle().comparisonExprChild();
    operator := object GeneralComp { operator := self.name.toGeneralComp() };
    right := self.ownedArguments->first().xmap toExprSingle().comparisonExprChild();
}

query ExprSingle::comparisonExprChild() : ComparisonExprChild =
    // Simplification: (...) <> (...) = ... <> ...
    if self.oclIsKindOf(ComparisonExprChild) then
        self.oclAsType(ComparisonExprChild)
    else
        object ParenthesizedExpr { expr := self }
    endif;

query OCLExpression::isNullLiteralExp() : Boolean = self.oclIsKindOf(NullLiteralExp);

query OrderedSet(OCLExpression)::isNullLiteralExp() : Boolean =
    self->size() = 1 and self->first().oclIsKindOf(NullLiteralExp);

query String::toGeneralComp() : GeneralCompKind =
      if (self = "=")  then GeneralCompKind::eq
    elif (self = "<>") then GeneralCompKind::ne
    elif (self = "<")  then GeneralCompKind::lt
    elif (self = "<=") then GeneralCompKind::le
    elif (self = ">")  then GeneralCompKind::gt
    elif (self = ">=") then GeneralCompKind::ge
    endif;

//////////////////////////////////////////////////////////////////////////////
// Arithmetic

mapping OperationCallExp::toAdditiveExpr() : AdditiveExpr
when { self.name.toAdditiveOp() <> null }
{
    var lhs := self.ownedSource.xmap toExprSingle().additiveExprOperand();
    var rhs := self.ownedArguments->first().xmap toExprSingle().additiveExprOperand();
    operand := lhs.operand;
    operand += rhs.operand;
    operator := lhs.operator;
    operator += self.name.toAdditiveOp();
    operator += rhs.operator;
}

mapping OperationCallExp::toMultiplicativeExpr() : MultiplicativeExpr
when { self.name.toMultiplicativeOp() <> null }
{
    var lhs := self.ownedSource.xmap toExprSingle().multiplicativeExprOperand();
    var rhs := self.ownedArguments->first().xmap toExprSingle().multiplicativeExprOperand();
    operand := lhs.operand;
    operand += rhs.operand;
    operator := lhs.operator;
    operator += self.name.toMultiplicativeOp();
    operator += rhs.operator;
}

query ExprSingle::additiveExprOperand() : AdditiveExpr =
    // Simplification: (... + ...) - ... = ... + ... - ...
    if self.oclIsKindOf(AdditiveExpr) then
        self.oclAsType(AdditiveExpr)
    // Simplification: (...) + ... = ... + ...
    elif self.oclIsKindOf(AdditiveExprChild) then
        object AdditiveExpr { operand := self.oclAsType(AdditiveExprChild); }
    else
        object AdditiveExpr { operand := object ParenthesizedExpr { expr := self } }
    endif;

query ExprSingle::multiplicativeExprOperand() : MultiplicativeExpr =
    // Simplification: (... * ...) / ... = ... * ... / ...
    if self.oclIsKindOf(MultiplicativeExpr) then
        self.oclAsType(MultiplicativeExpr)
    // Simplification: (...) * ... = ... * ...
    elif self.oclIsKindOf(MultiplicativeExprChild) then
        object MultiplicativeExpr { operand := self.oclAsType(MultiplicativeExprChild); }
    else
        object MultiplicativeExpr { operand := object ParenthesizedExpr { expr := self } }
    endif;

query String::toAdditiveOp() : AdditiveOpKind =
      if (self = "+") then AdditiveOpKind::addition
    elif (self = "-") then AdditiveOpKind::subtraction
    endif;

query String::toMultiplicativeOp() : MultiplicativeOpKind =
      if (self = "*")   then MultiplicativeOpKind::multiplication
    elif (self = "/")   then MultiplicativeOpKind::div
    elif (self = "div") then MultiplicativeOpKind::idiv
    elif (self = "mod") then MultiplicativeOpKind::mod
    endif;

//////////////////////////////////////////////////////////////////////////////
// Path
/*
mapping OCLExpression::toPath() : PathExpr
disjuncts
    PropertyCallExp::toPath,
    OperationCallExp::toPath
{
}

mapping OperationCallExp::toPath() : PathExpr
{
    init {
        // PropertyCallExp tree must be flattened.
        // VariableExp (self or iterator variable) is the innermost
        // component in an input tree, but it should be a first step
        // in an output path.
        log(self.ownedSource.metaClassName());
        result := self.ownedSource[PropertyCallExp]->collectOne(xmap toPath());
    }
}
*/

mapping VariableExp::toPathExpr() : PathExpr
{
    init {
        result := object PathExpr {
            step := object RootStepExpr { };
            step += object AbbrevForwardStep {
                kind := AbbrevForwardStepKind::child;
                nodeTest := object QNameTest { name := self.type.getQName() };
            };
        };
    }
}

mapping PropertyCallExp::toPathExpr() : PathExpr
{
    init {
        //log(self.repr());
        // PropertyCallExp tree must be flattened.
        // VariableExp (self or iterator variable) is the innermost
        // component in an input tree, but it should be a first step
        // in an output path.
        if (self.ownedSource.oclIsKindOf(VariableExp)) {
            if (self.ownedSource![VariableExp].referredVariable.name = 'self') {
                result := self.ownedSource[VariableExp]->collectOne(xmap toPathExpr());
            }
            else {
                result := object PathExpr { };
            }
        }
        elif (self.ownedSource.oclIsKindOf(PropertyCallExp)) {
            result := self.ownedSource[PropertyCallExp]->collectOne(xmap toPathExpr());
        }
        else {
            assert fatal (false);
        }
    }
    // Steps must be created only for Data Types. Data Elements must be skipped
    if (self.referredProperty.owningClass.isDataType()) {
        // Type can be a Set(T)
        var type := self.referredProperty.type.unwrap();
        
        var element : NamedElement;
        // Property is local
        if (type.isDataType()) {
            element := self.referredProperty;
        }
        // Property is a reference to a global element or attribute
        elif (type.isDataElement()) {
            element := type;
        }
        else {
            assert fatal (false) with log('Something is wrong');
        };

        var stepItem : AbbrevForwardStep;
        if (self.referredProperty.isAttribute()) {
            stepItem := object AbbrevForwardStep {
                kind := AbbrevForwardStepKind::attribute;
                nodeTest := object QNameTest { name := element.getUnprefixedQName() };
            };
        }
        else {
            stepItem := object AbbrevForwardStep {
                kind := AbbrevForwardStepKind::child;
                nodeTest := object QNameTest { name := element.getQName() };
            };
        };
        
        if (step->isEmpty()) {
            step := object SelfStepExpr { step := stepItem };
        }
        else {
            step += object ChildStepExpr { step := stepItem };
        }
    }
}

mapping OCLExpression::toPathExpr(predicate : ExprSingle) : PathExpr
{
    init {
        var path := self.xmap toExprSingle();
        assert fatal (path.oclIsKindOf(PathExpr)) with log('PathExpr expected instead of ' + path.metaClassName());
        path.oclAsType(PathExpr).getLastAxisStep().predicate := predicate.predicate();
        result := path.oclAsType(PathExpr);
    }
}

query PathExpr::getLastAxisStep() : AxisStep
{
    var lastStep = self.step->last();
    var axisStep : AxisStep;
    if (lastStep.oclIsKindOf(SelfStepExpr)) {
        axisStep := lastStep.oclAsType(SelfStepExpr).step.oclAsType(AxisStep);
    }
    elif (lastStep.oclIsKindOf(ChildStepExpr)) {
        axisStep := lastStep.oclAsType(ChildStepExpr).step.oclAsType(AxisStep);
    };
    assert fatal (axisStep <> null) with log('Last AxisStep not found');
    return axisStep;
} 

query ExprSingle::predicate() : Predicate =
    object Predicate { expr :=
        // Simplification: ...[fn:boolean(...)] = ...[...]
        if self.isFunctionCall('boolean'.createFunctionQName()) then
            self.oclAsType(FunctionCall).arg->first()
        else
            self
        endif };

//////////////////////////////////////////////////////////////////////////////
// Functions

mapping OperationCallExp::asSet() : ExprSingle
when { self.referredOperation.name = 'oclAsSet' }
{
    init {
        result := self.ownedSource.xmap toExprSingle();
    }
}

mapping OperationCallExp::toCountFunctionCall() : FunctionCall
when { self.referredOperation.name = 'size' and self.referredOperation.isCollectionOperation() }
{
    name := 'count'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle();
}

mapping OperationCallExp::toStringLengthFunctionCall() : FunctionCall
when { self.referredOperation.name = 'size' and not self.referredOperation.isCollectionOperation() }
{
    name := 'string-length'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle();
}

mapping OperationCallExp::toIsEmpty() : ExprSingle
when { self.referredOperation.name = 'isEmpty' }
{
    init {
    	result := self.ownedSource.xmap toExprSingle().notExpr();
    }
}

mapping OperationCallExp::toNotEmpty() : FunctionCall
when { self.referredOperation.name = 'notEmpty' }
{
    init {
        result := self.ownedSource.xmap toExprSingle().booleanExpr();
    }
}

mapping OperationCallExp::toSumFunctionCall() : FunctionCall
when { self.referredOperation.name = 'sum' and self.referredOperation.isCollectionOperation() }
{
    name := 'sum'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle();
}

mapping IteratorExp::isUnique() : FunctionCall
when { self.referredIteration.name = 'isUnique' }
{
    init {
        var nodesPath := self.ownedBody.xmap toExprSingle();
        var predicate := object ComparisonExpr {
            left := object FunctionCall {
                name := 'count'.createFunctionQName();
                arg := object FunctionCall {
                    name := 'distinct-values'.createFunctionQName();
                    arg := nodesPath;
                };
            };
            operator := object GeneralComp { operator := GeneralCompKind::eq };
            right := object FunctionCall {
                name := 'count'.createFunctionQName();
                arg := nodesPath.deepclone().oclAsType(ExprSingle);
            }
        };
        result := self.ownedSource.xmap toPathExpr(predicate).booleanExpr();
    }
}

//////////////////////////////////////////////////////////////////////////////
// Literals

mapping IntegerLiteralExp::toLiteral() : IntegerLiteral
{
    value := self.integerSymbol.oclAsType(Integer);
}

mapping UnlimitedNaturalLiteralExp::toLiteral() : IntegerLiteral
{
    value := self.unlimitedNaturalSymbol.oclAsType(Integer);
}

mapping RealLiteralExp::toLiteral() : NumericLiteral
{
    init {
        var val := self.realSymbol.repr().toReal();
        result := if (val.repr().matches('.+[eE].+'))
            then object DoubleLiteral { value := val }
            else object DecimalLiteral { value := val } endif;
    }
}

mapping StringLiteralExp::toLiteral() : StringLiteral
{
    value := self.stringSymbol.quote();
}

mapping BooleanLiteralExp::toLiteral() : FunctionCall
{
    name := if self.booleanSymbol then 'true' else 'false' endif.createFunctionQName();
}

//////////////////////////////////////////////////////////////////////////////
// Unknown expressions

mapping OCLExpression::riseError() : StringLiteral
{
    assert fatal (false) with log('Unknown ' + self.metaClassName() + ' ' + self.repr());
}

//////////////////////////////////////////////////////////////////////////////
// Helpers

query NamedElement::unwrap() : NamedElement =
    if self.oclIsKindOf(SetType) then self.oclAsType(SetType).elementType else self endif;

query NamedElement::getQName() : QName = self.getETarget().getQName();

query NamedElement::getUnprefixedQName() : QName = self.getETarget().getUnprefixedQName();

query NamedElement::isDataType() : Boolean = self.getETarget().isDataType();

query NamedElement::isDataElement() : Boolean = self.getETarget().isDataElement();

query Property::isAttribute() : Boolean = self.getETarget().isAttribute();

query Operation::isBooleanOperation(name : String) : Boolean = 
    self.owningClass.oclIsKindOf(PrimitiveType) and
    self.owningClass.name = 'Boolean' and
    self.name = name;

query Operation::isCollectionOperation() : Boolean = 
    self.owningClass.oclIsKindOf(CollectionType);

query ExprSingle::isFunctionCall(name : QName) : Boolean =
    self.oclIsKindOf(FunctionCall) and self.oclAsType(FunctionCall).name = name;

query String::createFunctionQName() : QName =
    if useFunctionQNames
    then createQName('http://www.w3.org/2005/xpath-functions', self, 'fn')
    else createQName(self) endif;
