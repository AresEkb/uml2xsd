/**
 * Copyright (c) 2013, 2016 Denis Nikiforov.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *    Denis Nikiforov - initial API and implementation
 */

// There are some XPath AST simplifications in the code.
// It would be great to separate them from the transformation,
// but the problem is that simplification mapping should traverse
// whole AST and therefore it will be even more complex than an
// OCL to XPath transformation itself.

// TODO: Context is needed to transform variables.
// For example self may be transformed into either empty step or parent step

import uml2xsd.UtilitiesLibrary;
import Helpers;

modeltype OCL 'strict' uses 'http://www.eclipse.org/ocl/2015/Pivot';
modeltype XPATH2 'strict' uses 'http://www.emftext.org/language/xpath2';
modeltype TYPE uses 'http://www.eclipse.org/emf/2003/XMLType';

library OCLtoXPath;

property useFunctionQNames : Boolean = true;

// TODO: Replace by context
property emptySelf : Boolean = false;

--intermediate class Context { variables : Dict(OCL::Variable, XPATH2::ExprSingle); };

mapping ExpressionInOCL::toXPath() : Expr
{
    //log('    Transforming OCL expression\n      ' + self.body.replaceAll('\n', '\n      '));
    var variables : Dict(OCL::Variable, XPATH2::ExprSingle);
    expr := self.ownedBody.xmap toExprSingle(variables);
    //log('    to\n      ' + result.toString());
}

mapping OCLExpression::toExprSingle(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
disjuncts
    // Logic
    OperationCallExp::toOrExpr,
    OperationCallExp::toAndExpr,
    OperationCallExp::toImplies,
    OperationCallExp::toNotExpr,
    IteratorExp::toExists,
    IteratorExp::toForAll,
    // Comparision
    OperationCallExp::toLeftNotNull,
    OperationCallExp::toRightNotNull,
    OperationCallExp::toComparisonExpr,
    // Arithmetic
    OperationCallExp::toAdditiveExpr,
    OperationCallExp::toMultiplicativeExpr,
    // Path
    VariableExp::toPathExpr1,
    VariableExp::toPathExpr2,
    VariableExp::toPathExpr3,
    PropertyCallExp::toPathExpr,
    IteratorExp::toPathExpr,
    // Functions
    OperationCallExp::toAsSet,
    OperationCallExp::toDistinctValues,
    OperationCallExp::toCountFunctionCall,
    OperationCallExp::toIncludesFunctionCall,
    OperationCallExp::toStringLengthFunctionCall,
    OperationCallExp::toIsEmpty,
    OperationCallExp::toNotEmpty,
    OperationCallExp::toMatches,
    OperationCallExp::toReplaceAll,
    OperationCallExp::toCodePoints,
    OperationCallExp::toSumFunctionCall,
    IteratorExp::toIsUnique,
    OperationCallExp::toHasTimezoneFunctionCall,
    OperationCallExp::toNewDuration,
    OperationCallExp::toDateCast,
    OperationCallExp::toGetWorkingDays,
    // Literals
    IntegerLiteralExp::toLiteral,
    UnlimitedNaturalLiteralExp::toLiteral,
    RealLiteralExp::toLiteral,
    StringLiteralExp::toLiteral,
    BooleanLiteralExp::toLiteral,
    CollectionLiteralExp::toSequence,
    // Constructions
    IfExp::toIfElse,
    // Unknown expressions
    OCLExpression::raiseError
{
}

//////////////////////////////////////////////////////////////////////////////
// Logic

mapping OperationCallExp::toOrExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredOperation.isBooleanOperation('or') }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables).orExpr(
            self.ownedArguments->first().xmap toExprSingle(variables));
    }
}

mapping OperationCallExp::toAndExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : AndExpr
when { self.referredOperation.isBooleanOperation('and') }
{
    operand := self.ownedSource.xmap toExprSingle(variables).andExprOperand();
    operand += self.ownedArguments->first().xmap toExprSingle(variables).andExprOperand();
}

mapping OperationCallExp::toImplies(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredOperation.isBooleanOperation('implies') }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables).notExpr().orExpr(
            self.ownedArguments->first().xmap toExprSingle(variables));
    }
}

mapping OperationCallExp::toNotExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredOperation.isBooleanOperation('not') }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables).notExpr();
    }
}

mapping IfExp::toIfElse(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : IfExpr
{
    test:= self.ownedCondition.xmap toExprSingle(variables);
    _then:= self.ownedThen.xmap toExprSingle(variables);
    _else:= self.ownedElse.xmap toExprSingle(variables);
}

mapping IteratorExp::toExists(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredIteration.name = 'exists' }
{
    init {
        result := self.ownedSource.xmap toPathExpr(variables, self.ownedBody.xmap toExprSingle(variables)).booleanExpr();
    }
}

mapping IteratorExp::toForAll(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredIteration.name = 'forAll' }
{
    init {
        result := self.ownedSource.xmap toPathExpr(variables, self.ownedBody.xmap toExprSingle(variables).notExpr()).notExpr();
    }
}

query ExprSingle::booleanExpr() : FunctionCall = object FunctionCall { name := 'boolean'.createFunctionQName(); arg := self; };

query ExprSingle::notExpr() : ExprSingle =
    // Simplification: fn:not(fn:not(...)) = fn:boolean(...)
    if self.isFunctionCall('not'.createFunctionQName()) then
        self.oclAsType(FunctionCall).arg->collectOne(booleanExpr())
    // Simplification: fn:not(fn:boolean(...)) = fn:not(...)
    elif self.isFunctionCall('boolean'.createFunctionQName()) then
        self.oclAsType(FunctionCall).arg->collectOne(notExpr())
    // Simplification: fn:not(fn:not(...) and fn:not(...) and ...) = (... or ... or ...)
    elif self.oclIsKindOf(AndExpr) and self.oclAsType(AndExpr).operand->forAll(isFunctionCall('not'.createFunctionQName())) then
        object OrExpr { operand :=
            self.oclAsType(AndExpr).operand->collect(
                oclAsType(FunctionCall).arg->first().orExprOperand()) }
    // Simplification: fn:not(fn:not(...) or fn:not(...) or ...) = (... and ... and ...)
    elif self.oclIsKindOf(OrExpr) and self.oclAsType(OrExpr).operand->forAll(isFunctionCall('not'.createFunctionQName())) then
        object AndExpr { operand :=
            self.oclAsType(OrExpr).operand->collect(
                oclAsType(FunctionCall).arg->first().andExprOperand()) }
    // Simplification: fn:not(fn:exists(...)) = fn:empty(...)
    elif self.isFunctionCall('exists'.createFunctionQName()) then
        object FunctionCall { name := 'empty'.createFunctionQName(); arg := self.oclAsType(FunctionCall).arg; }
    // Simplification: fn:not(fn:empty(...)) = fn:exists(...)
    elif self.isFunctionCall('empty'.createFunctionQName()) then
        object FunctionCall { name := 'exists'.createFunctionQName(); arg := self.oclAsType(FunctionCall).arg; }
    else
        object FunctionCall { name := 'not'.createFunctionQName(); arg := self; }
    endif;

query ExprSingle::orExpr(rhs : ExprSingle) : ExprSingle
{
    var operands := self.orExprOperand();
    operands += rhs.orExprOperand();
    return 
    // Simplification: fn:not(...) or fn:not(...) = fn:not(... and ...)
    if operands->forAll(isFunctionCall('not'.createFunctionQName())) then
        object AndExpr { operand :=
            operands->collect(
                oclAsType(FunctionCall).arg->first().andExprOperand()) }.notExpr()
    else
        object OrExpr { operand := operands }
    endif;
}

query ExprSingle::orExprOperand() : OrderedSet(OrExprChild) =
    // Simplification: (... or ...) or ... = ... or ... or ...
    if self.oclIsKindOf(OrExpr) then
        self.oclAsType(OrExpr).operand
    // Simplification: fn:boolean(...) or ... = ... or ...
    elif self.isFunctionCall('boolean'.createFunctionQName()) then
        self.oclAsType(FunctionCall).arg
    // Simplification: (...) or ... = ... or ...
    elif self.oclIsKindOf(OrExprChild) then
        self.oclAsType(OrExprChild)->asOrderedSet()
    else
        object ParenthesizedExpr { expr := self }->asOrderedSet()
    endif;

query ExprSingle::andExprOperand() : OrderedSet(AndExprChild) =
    // Simplification: (... and ...) and ... = ... and ... and ...
    if self.oclIsKindOf(AndExpr) then
        self.oclAsType(AndExpr).operand
    // Simplification: fn:boolean(...) and ... = ... and ...
    elif self.isFunctionCall('boolean'.createFunctionQName()) then
        self.oclAsType(FunctionCall).arg
    // Simplification: (...) and ... = ... and ...
    elif self.oclIsKindOf(AndExprChild) then
        self.oclAsType(AndExprChild)->asOrderedSet()
    else
        object ParenthesizedExpr { expr := self }->asOrderedSet()
    endif;

//////////////////////////////////////////////////////////////////////////////
// Comparision

mapping OperationCallExp::toLeftNotNull(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.name = '<>' and self.ownedArguments->isNullLiteralExp() }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables);
    }
}

mapping OperationCallExp::toRightNotNull(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.name = '<>' and self.ownedSource.isNullLiteralExp() }
{
    init {
        result := self.ownedArguments->first().xmap toExprSingle(variables);
    }
}

mapping OperationCallExp::toComparisonExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ComparisonExpr
when { self.name.toGeneralComp() <> null and not(self.ownedSource.isNullLiteralExp() or self.ownedArguments->isNullLiteralExp()) }
{
    left := self.ownedSource.xmap toExprSingle(variables).comparisonExprChild();
    operator := object GeneralComp { operator := self.name.toGeneralComp() };
    right := self.ownedArguments->first().xmap toExprSingle(variables).comparisonExprChild();
}

query ExprSingle::comparisonExprChild() : ComparisonExprChild =
    // Simplification: (...) <> (...) = ... <> ...
    if self.oclIsKindOf(ComparisonExprChild) then
        self.oclAsType(ComparisonExprChild)
    else
        object ParenthesizedExpr { expr := self }
    endif;

query OCLExpression::isNullLiteralExp() : Boolean = self.oclIsKindOf(NullLiteralExp);

query OrderedSet(OCLExpression)::isNullLiteralExp() : Boolean =
    self->size() = 1 and self->first().oclIsKindOf(NullLiteralExp);

query String::toGeneralComp() : GeneralCompKind =
      if (self = "=")  then GeneralCompKind::eq
    elif (self = "<>") then GeneralCompKind::ne
    elif (self = "<")  then GeneralCompKind::lt
    elif (self = "<=") then GeneralCompKind::le
    elif (self = ">")  then GeneralCompKind::gt
    elif (self = ">=") then GeneralCompKind::ge
    endif;

//////////////////////////////////////////////////////////////////////////////
// Arithmetic

mapping OperationCallExp::toAdditiveExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : AdditiveExpr
when { self.name.toAdditiveOp() <> null }
{
    var lhs := self.ownedSource.xmap toExprSingle(variables).additiveExprOperand();
    var rhs := self.ownedArguments->first().xmap toExprSingle(variables).additiveExprOperand();
    operand := lhs.operand;
    operand += rhs.operand;
    operator := lhs.operator;
    operator += self.name.toAdditiveOp();
    operator += rhs.operator;
}

mapping OperationCallExp::toMultiplicativeExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : MultiplicativeExpr
when { self.name.toMultiplicativeOp() <> null }
{
    var lhs := self.ownedSource.xmap toExprSingle(variables).multiplicativeExprOperand();
    var rhs := self.ownedArguments->first().xmap toExprSingle(variables).multiplicativeExprOperand();
    operand := lhs.operand;
    operand += rhs.operand;
    operator := lhs.operator;
    operator += self.name.toMultiplicativeOp();
    operator += rhs.operator;
}

query ExprSingle::additiveExprOperand() : AdditiveExpr =
    // Simplification: (... + ...) - ... = ... + ... - ...
    if self.oclIsKindOf(AdditiveExpr) then
        self.oclAsType(AdditiveExpr)
    // Simplification: (...) + ... = ... + ...
    elif self.oclIsKindOf(AdditiveExprChild) then
        object AdditiveExpr { operand := self.oclAsType(AdditiveExprChild); }
    else
        object AdditiveExpr { operand := object ParenthesizedExpr { expr := self } }
    endif;

query ExprSingle::multiplicativeExprOperand() : MultiplicativeExpr =
    // Simplification: (... * ...) / ... = ... * ... / ...
    if self.oclIsKindOf(MultiplicativeExpr) then
        self.oclAsType(MultiplicativeExpr)
    // Simplification: (...) * ... = ... * ...
    elif self.oclIsKindOf(MultiplicativeExprChild) then
        object MultiplicativeExpr { operand := self.oclAsType(MultiplicativeExprChild); }
    else
        object MultiplicativeExpr { operand := object ParenthesizedExpr { expr := self } }
    endif;

query String::toAdditiveOp() : AdditiveOpKind =
      if (self = "+") then AdditiveOpKind::addition
    elif (self = "-") then AdditiveOpKind::subtraction
    endif;

query String::toMultiplicativeOp() : MultiplicativeOpKind =
      if (self = "*")   then MultiplicativeOpKind::multiplication
    elif (self = "/")   then MultiplicativeOpKind::div
    elif (self = "div") then MultiplicativeOpKind::idiv
    elif (self = "mod") then MultiplicativeOpKind::mod
    endif;

//////////////////////////////////////////////////////////////////////////////
// Path

/*
mapping OCLExpression::toPath() : PathExpr
disjuncts
    PropertyCallExp::toPath,
    OperationCallExp::toPath
{
}

mapping OperationCallExp::toPath() : PathExpr
{
    init {
        // PropertyCallExp tree must be flattened.
        // VariableExp (self or iterator variable) is the innermost
        // component in an input tree, but it should be a first step
        // in an output path.
        log(self.ownedSource.metaClassName());
        result := self.ownedSource[PropertyCallExp]->collectOne(xmap toPath());
    }
}
*/

// TODO: All this code must be refactored
mapping OCLExpression::toPathExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : PathExpr
disjuncts
    VariableExp::toPathExpr1,
    VariableExp::toPathExpr2,
    VariableExp::toPathExpr3,
    PropertyCallExp::toPathExpr,
    OCLExpression::raiseError
{
}

// Self
mapping VariableExp::toPathExpr1(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : PathExpr
when { self.referredVariable.name = 'self' }
{
    if (not emptySelf) {
        step := object RootStepExpr { };
        step += object AbbrevForwardStep {
            kind := AbbrevForwardStepKind::child;
            nodeTest := object QNameTest { name := self.type.getQName() };
        };
    }
    else {
    	step := object SelfStepExpr {
    		step := object ContextItemExpr { };
    	};
    }
}

// Iterator
mapping VariableExp::toPathExpr2(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : PathExpr
when { self.referredVariable.name <> 'self' and self.referredVariable![Variable].representedParameter <> null }
{
    step := object SelfStepExpr {
        step := object ContextItemExpr { };
    };
}

// Declared variable
mapping VariableExp::toPathExpr3(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : PathExpr
when { self.referredVariable.name <> 'self' and self.referredVariable![Variable].representedParameter = null }
{
    var variable := variables->get(self.referredVariable![Variable]);
    assert fatal (variable.oclIsKindOf(VarRef)) with log ('Variable ' + self.referredVariable.toString() + ' not found');
    step := variable![VarRef];
}

mapping PropertyCallExp::toPathExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : PathExpr
{
    init {
        //log(self.repr());
        // PropertyCallExp tree must be flattened.
        // VariableExp (self or iterator variable) is the innermost
        // component in an input tree, but it should be a first step
        // in an output path.
        result := self.ownedSource.xmap toPathExpr(variables);
        /*if (self.ownedSource.oclIsKindOf(VariableExp)) {
            if (self.ownedSource![VariableExp].referredVariable.name = 'self') {
                //result := self.ownedSource[VariableExp]->collectOne(xmap toPathExpr());
                result := object PathExpr { };
            }
            else {
                result := object PathExpr { };
            }
        }
        elif (self.ownedSource.oclIsKindOf(PropertyCallExp)) {
            result := self.ownedSource[PropertyCallExp]->collectOne(xmap toPathExpr());
        }
        else {
            raise Exception('Something is wrong');
        }*/
    }
    
    // Steps must be created only for Data Types. Data Elements must be skipped
    if (self.referredProperty.owningClass.isDataType()) {
        // Type can be a Set(T)
        var type := self.referredProperty.type.unwrap();
        
        // TODO: Something more adequate is needed here
        if (type.toString() = 'OclVoid') {
            raise Exception('Property doesn\'t have a type');
        };
        
        var element : NamedElement;
        // Property is local
        if (type.isDataType()) {
            element := self.referredProperty;
        }
        // Property is a reference to a global element or attribute
        elif (type.isDataElement()) {
            element := type;
        }
        else {
            raise Exception('Something is wrong');
        };

        var stepItem : AbbrevForwardStep;
        if (self.referredProperty.isAttribute()) {
            stepItem := object AbbrevForwardStep {
                kind := AbbrevForwardStepKind::attribute;
                nodeTest := object QNameTest { name := element.getUnprefixedQName() };
            };
        }
        else {
            stepItem := object AbbrevForwardStep {
                kind := AbbrevForwardStepKind::child;
                nodeTest := object QNameTest { name := element.getQName() };
            };
        };
        
        // Simplification: ./path/... = path/...
        if (step->size() >= 1) {
            if (step->at(1)[SelfStepExpr].step->one(oclIsKindOf(ContextItemExpr))) {
                if (step->size() = 1) {
                    step := OrderedSet { };
                }
                else {
                    step := step->subOrderedSet(2, step->size());
                }
        	}
        };
        
        if (step->isEmpty()) {
            step := object SelfStepExpr { step := stepItem };
        }
        else {
            step += object ChildStepExpr { step := stepItem };
        }
    }
    elif (self.referredProperty.owningClass.isDataElement()) {
    }
    else {
        raise Exception('Something is wrong');
    }
}

mapping OCLExpression::toPathExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle), predicate : ExprSingle) : PathExpr
{
    init {
        var path := self.xmap toExprSingle(variables);
        assert fatal (path.oclIsKindOf(PathExpr)) with log('PathExpr expected instead of ' + path.metaClassName());
        path.oclAsType(PathExpr).getLastAxisStep().predicate := predicate.predicate();
        result := path.oclAsType(PathExpr);
    }
}

// TODO: Refactor it
// collect iteration indicates multivalued features. It must not be ignored.
mapping IteratorExp::toPathExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : PathExpr
when { self.referredIteration.name = 'collect' }
{
    init {
        result := self.ownedSource.xmap toPathExpr(variables);
    }
    var body := self.ownedBody.xmap toExprSingle(variables);
    //log(' --- BODY: ' + self.ownedBody.repr());
    //log(' --- PATH: ' + body.toString());
    step += object ChildStepExpr {
        step := if body.oclIsKindOf(StepExprChild)
            then body.oclAsType(StepExprChild)
            else object ParenthesizedExpr { expr := body; } endif;
    };
    /*
    assert fatal (body.oclIsKindOf(PathExpr)) with log('PathExpr expected instead of ' + body.metaClassName());
    body.oclAsType(PathExpr).step->forEach (s) {
        if (s.oclIsKindOf(SelfStepExpr)) {
            step += object ChildStepExpr {
                step := s.oclAsType(SelfStepExpr).step.oclAsType(StepExpr);
            }
        }
        elif (s.oclIsKindOf(ChildStepExpr)) {
            step += s;
        }
        else {
        	assert fatal (false);
        };
    };
    */
}

query PathExpr::getLastAxisStep() : AxisStep
{
    var lastStep = self.step->last();
    var axisStep : AxisStep;
    if (lastStep.oclIsKindOf(SelfStepExpr)) {
        axisStep := lastStep.oclAsType(SelfStepExpr).step.oclAsType(AxisStep);
    }
    elif (lastStep.oclIsKindOf(ChildStepExpr)) {
        axisStep := lastStep.oclAsType(ChildStepExpr).step.oclAsType(AxisStep);
    };
    assert fatal (axisStep <> null) with log('Last AxisStep not found');
    return axisStep;
} 

query ExprSingle::predicate() : Predicate =
    object Predicate { expr :=
        // Simplification: ...[fn:boolean(...)] = ...[...]
        if self.isFunctionCall('boolean'.createFunctionQName()) then
            self.oclAsType(FunctionCall).arg->first()
        else
            self
        endif };

//////////////////////////////////////////////////////////////////////////////
// Functions

mapping OperationCallExp::toAsSet(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredOperation.name = 'oclAsSet' }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables);
    }
}

mapping OperationCallExp::toDistinctValues(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'asSet' and self.ownedArguments->isEmpty() }
{
    name := 'distinct-values'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
}

mapping OperationCallExp::toCountFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'size' and self.referredOperation.isCollectionOperation() }
{
    name := 'count'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
}

mapping OperationCallExp::toIncludesFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'includes' and self.referredOperation.isCollectionOperation() }
{
    name := 'exists'.createFunctionQName();
    arg := self.xmap toIndexOfFunctionCall(variables);
}

mapping OperationCallExp::toIndexOfFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
{
    name := 'index-of'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
    arg += self.ownedArguments->toExprSingle(variables);
}

mapping OperationCallExp::toStringLengthFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'size' and not self.referredOperation.isCollectionOperation() }
{
    name := 'string-length'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
}

mapping OperationCallExp::toIsEmpty(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredOperation.name = 'isEmpty' }
{
    init {
    	result := self.ownedSource.xmap toExprSingle(variables).notExpr();
    }
}

mapping OperationCallExp::toNotEmpty(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'notEmpty' }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables).booleanExpr();
    }
}

mapping OperationCallExp::toMatches(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'matches' and self.ownedArguments->one(oclIsKindOf(StringLiteralExp)) }
{
    name := 'matches'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
    arg += self.ownedArguments->toExprSingle(variables);
}

mapping OperationCallExp::toReplaceAll(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'replaceAll' and self.ownedArguments->size() = 2 and self.ownedArguments->forAll(oclIsKindOf(StringLiteralExp)) }
{
    name := 'replace'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
    arg += self.ownedArguments->toExprSingle(variables);
}

mapping OperationCallExp::toCodePoints(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'toCodePoints' and self.ownedArguments->isEmpty() }
{
    name := 'string-to-codepoints'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
}

mapping OperationCallExp::toSumFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'sum' and self.referredOperation.isCollectionOperation() }
{
    name := 'sum'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
}

mapping IteratorExp::toIsUnique(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredIteration.name = 'isUnique' }
{
    init {
        var nodesPath := self.ownedBody.xmap toExprSingle(variables);
        var predicate := object ComparisonExpr {
            left := object FunctionCall {
                name := 'count'.createFunctionQName();
                arg := object FunctionCall {
                    name := 'distinct-values'.createFunctionQName();
                    arg := nodesPath;
                };
            };
            operator := object GeneralComp { operator := GeneralCompKind::eq };
            right := object FunctionCall {
                name := 'count'.createFunctionQName();
                arg := nodesPath.deepclone().oclAsType(ExprSingle);
            }
        };
        result := self.ownedSource.xmap toPathExpr(variables, predicate).booleanExpr();
    }
}

mapping OperationCallExp::toHasTimezoneFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'hasTimezone' }
{
    name := 'exists'.createFunctionQName();
    arg := self.xmap toGetTimezoneFunctionCall(variables);
}

mapping OperationCallExp::toGetTimezoneFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
disjuncts
    OperationCallExp::toGetTimezoneFromDateTimeFunctionCall,
    OperationCallExp::toGetTimezoneFromDateFunctionCall,
    OperationCallExp::toGetTimezoneFromTimeFunctionCall
{
}

mapping OperationCallExp::toGetTimezoneFromDateTimeFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'hasTimezone' and self.referredOperation.owningClass.isDateTimeType() }
{
    name := 'timezone-from-dateTime'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
}

mapping OperationCallExp::toGetTimezoneFromDateFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'hasTimezone' and self.referredOperation.owningClass.isDateType() }
{
    name := 'timezone-from-date'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
}

mapping OperationCallExp::toGetTimezoneFromTimeFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'hasTimezone' and self.referredOperation.owningClass.isTimeType() }
{
    name := 'timezone-from-time'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
}

mapping OperationCallExp::toNewDuration(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredOperation.name = 'new' and self.referredOperation.owningClass.isDurationType() }
{
    init {
        result := self.ownedArguments->asSequence()->at(1).xmap toExprSingle(variables);
    }
}

mapping OperationCallExp::toDateCast(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredOperation.name = 'toDate' and self.referredOperation.owningClass.isDateTimeType() }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables);
    }
}

// TODO: It returns duration without any change, but must return working days duration
mapping OperationCallExp::toGetWorkingDays(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredOperation.name = 'getWorkingDays' and self.referredOperation.owningClass.isDurationType() }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables);
    }
}

//////////////////////////////////////////////////////////////////////////////
// Literals

mapping IntegerLiteralExp::toLiteral(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : IntegerLiteral
{
    value := self.integerSymbol.oclAsType(Integer);
}

mapping UnlimitedNaturalLiteralExp::toLiteral(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : IntegerLiteral
{
    value := self.unlimitedNaturalSymbol.oclAsType(Integer);
}

mapping RealLiteralExp::toLiteral(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : NumericLiteral
{
    init {
        var val := self.realSymbol.repr().toReal();
        result := if (val.repr().matches('.+[eE].+'))
            then object DoubleLiteral { value := val }
            else object DecimalLiteral { value := val } endif;
    }
}

mapping StringLiteralExp::toLiteral(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : StringLiteral
{
    value := self.stringSymbol.quote();
}

mapping BooleanLiteralExp::toLiteral(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
{
    name := if self.booleanSymbol then 'true' else 'false' endif.createFunctionQName();
}

mapping CollectionLiteralExp::toSequence(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ParenthesizedExpr
{
    assert fatal (self.ownedParts->forAll(oclIsKindOf(CollectionItem))) with log ('Only CollectionItem supported');
    expr := object Expr {
        expr := self.ownedParts[CollectionItem].ownedItem->toExprSingle(variables)
    };
}

//////////////////////////////////////////////////////////////////////////////
// Unknown expressions

mapping OCLExpression::raiseError(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : PathExpr
{
    var message = 'Unknown expression with meta-class: "' + self.metaClassName() + '" : ' + self.repr();
    log(message);
    raise Exception(message);
}

//////////////////////////////////////////////////////////////////////////////
// Helpers

query NamedElement::unwrap() : NamedElement =
    if self.oclIsKindOf(SetType) then self.oclAsType(SetType).elementType else self endif;

query NamedElement::getQName() : QName = self.getETarget().getQName();

query NamedElement::getUnprefixedQName() : QName = self.getETarget().getUnprefixedQName();

query NamedElement::isDataType() : Boolean = self.getETarget().isDataType();

query NamedElement::isDateType() : Boolean = self.getETarget().isDateType();

query NamedElement::isDateTimeType() : Boolean = self.getETarget().isDateTimeType();

query NamedElement::isTimeType() : Boolean = self.getETarget().isTimeType();

query NamedElement::isDurationType() : Boolean = self.getETarget().isDurationType();

query NamedElement::isDataElement() : Boolean = self.getETarget().isDataElement();

query Property::isAttribute() : Boolean = self.getETarget().isAttribute();

query Operation::isBooleanOperation(name : String) : Boolean = 
    self.owningClass.oclIsKindOf(PrimitiveType) and
    self.owningClass.name = 'Boolean' and
    self.name = name;

query Operation::isCollectionOperation() : Boolean = 
    self.owningClass.oclIsKindOf(CollectionType);

query ExprSingle::isFunctionCall(name : QName) : Boolean =
    self.oclIsKindOf(FunctionCall) and self.oclAsType(FunctionCall).name = name;

query String::createFunctionQName() : QName =
    if useFunctionQNames
    then createQName('http://www.w3.org/2005/xpath-functions', self, 'fn')
    else createQName(self) endif;
