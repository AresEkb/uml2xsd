/**
 * Copyright (c) 2013, 2016 Denis Nikiforov.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Denis Nikiforov - initial API and implementation
 */

// There are some XPath AST simplifications in the code.
// It would be great to separate them from the transformation,
// but the problem is that simplification mapping should traverse
// whole AST and therefore it will be even more complex than an
// OCL to XPath transformation itself.

// TODO: Context is needed to transform variables.
// For example self may be transformed into either empty step or parent step
// XPath expressions for variables can't be determined outside this transformation
// They must be either fully determinied inside transformations, either must be transformed
// From the other point of view expressions like $var doesn't need any transformation, they are fixed.
// Also absolute path must not be transformed. Only relative one needs transformation

import Helpers;

modeltype OCL 'strict' uses 'http://www.eclipse.org/ocl/2015/Pivot';
modeltype XPATH2 'strict' uses 'http://www.emftext.org/language/xpath2';
modeltype TYPE uses 'http://www.eclipse.org/emf/2003/XMLType';

library OCLtoXPath;

mapping ExpressionInOCL::toXPath() : Expr
{
    //log('    Transforming OCL expression\n      ' + self.body.replaceAll('\n', '\n      '));
    var variables : Dict(OCL::Variable, XPATH2::ExprSingle);
    expr := self.ownedBody.xmap toExprSingle(variables);
    //log('    to\n      ' + result.toString());
}

mapping OCLExpression::toExprSingle(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
disjuncts
    // Logic
    OperationCallExp::toOrExpr,
    OperationCallExp::toAndExpr,
    OperationCallExp::toImplies,
    OperationCallExp::toNotExpr,
    IteratorExp::toExists,
    IteratorExp::toForAll,
    IteratorExp::toOne,
    IteratorExp::toSelect,
    IteratorExp::toReject,
    OperationCallExp::toIncluding,
    // Comparision
    OperationCallExp::toLeftNotNull,
    OperationCallExp::toRightNotNull,
    OperationCallExp::toComparisonExpr,
    // Arithmetic
    OperationCallExp::toAdditiveExpr,
    OperationCallExp::toMultiplicativeExpr,
    // Cast
    OperationCallExp::toInteger,
    // Path
    VariableExp::toPathExpr,
    VariableExp::toVarRef,
    PropertyCallExp::toPathExpr,
    IteratorExp::toCollect,
    // Functions
    OperationCallExp::toAsSet,
    OperationCallExp::toAsType,
    OperationCallExp::toDistinctValues,
    OperationCallExp::toCountFunctionCall,
    OperationCallExp::toIncludesFunctionCall,
    OperationCallExp::toStringLengthFunctionCall,
    OperationCallExp::toIsEmpty,
    OperationCallExp::toNotEmpty,
    OperationCallExp::toSubstring,
    OperationCallExp::toMatches,
    OperationCallExp::toReplaceAll,
    OperationCallExp::toCodePoints,
    OperationCallExp::toSumFunctionCall,
    IteratorExp::toIsUnique,
    OperationCallExp::toHasTimezoneFunctionCall,
    OperationCallExp::toNewDuration,
    OperationCallExp::toDateCast,
    OperationCallExp::toGetWorkingDays,
    // Literals
    IntegerLiteralExp::toLiteral,
    UnlimitedNaturalLiteralExp::toLiteral,
    RealLiteralExp::toLiteral,
    StringLiteralExp::toLiteral,
    BooleanLiteralExp::toLiteral,
    CollectionLiteralExp::toSequence,
    // Constructions
    IfExp::toIfElse,
    // External
    IteratorExp::toExternalExists,
    // Unknown expressions
    OCLExpression::raiseError
{
}

//////////////////////////////////////////////////////////////////////////////
// Logic

mapping OperationCallExp::toOrExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredOperation.isBooleanOperation('or') }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables).orExpr(
            self.ownedArguments->first().xmap toExprSingle(variables));
    }
}

mapping OperationCallExp::toAndExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : AndExpr
when { self.referredOperation.isBooleanOperation('and') }
{
    operand := self.ownedSource.xmap toExprSingle(variables).andExprOperand();
    operand += self.ownedArguments->first().xmap toExprSingle(variables).andExprOperand();
}

mapping OperationCallExp::toImplies(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredOperation.isBooleanOperation('implies') }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables).notExpr().orExpr(
            self.ownedArguments->first().xmap toExprSingle(variables));
    }
}

mapping OperationCallExp::toNotExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredOperation.isBooleanOperation('not') }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables).notExpr();
    }
}

mapping IfExp::toIfElse(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : IfExpr
{
    test:= self.ownedCondition.xmap toExprSingle(variables);
    _then:= self.ownedThen.xmap toExprSingle(variables);
    _else:= self.ownedElse.xmap toExprSingle(variables);
}

mapping IteratorExp::toExists(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredIteration.name = 'exists' and not self.isExternal() }
{
    init {
        result := self.ownedSource.xmap toPathExpr(variables, self.ownedBody.xmap toExprSingle(variables)).booleanExpr();
    }
}

mapping IteratorExp::toForAll(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredIteration.name = 'forAll' }
{
    init {
        result := self.ownedSource.xmap toPathExpr(variables, self.ownedBody.xmap toExprSingle(variables).notExpr()).notExpr();
    }
}

// Note: fn:exactly-one can't be used here, because it returns a single object contained in the sequence
// and raises an error if sequence isn't a singleton. But this operation must return true/false instead.
mapping IteratorExp::toOne(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ComparisonExpr
when { self.referredIteration.name = 'one' }
{
    left := object FunctionCall {
        name := 'count'.createFunctionQName();
        arg := self.ownedSource.xmap toPathExpr(variables, self.ownedBody.xmap toExprSingle(variables));
    };
    operator := object GeneralComp { operator := GeneralCompKind::eq };
    right := object IntegerLiteral { value := 1 };
}

// TODO: This logic must be in all other places too
mapping IteratorExp::toSelect(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredIteration.name = 'select' }
{
    init {
        assert fatal (self.ownedIterators->size() = 1) with log('Expected exactly 1 iterator in select');
        var iter := self.ownedIterators->any(true);

        var iterators := self.ownedBody.findNestedIteratorExps();

        if (iterators->exists(hasReferenceTo(iter))) {
            var variableName := createQName(iter.name);
            result := object ForExpr {
                iterator := object Iterator {
                    varName := variableName;
                    list := self.ownedSource.xmap toExprSingle(variables);
                };
                _return := object IfExpr {
                    var variables2 : Dict(OCL::Variable, XPATH2::ExprSingle);
                    variables->keys()->forEach (key) {
                        variables2->put(key, variables->get(key));
                    };
                    variables2->put(iter, object VarRef { varName := variableName });

                    test := self.ownedBody.xmap toExprSingle(variables2);
                    _then := object VarRef { varName := variableName };
                    _else := object ParenthesizedExpr { };
                };
            };
        }
        else {
            result := self.ownedSource.xmap toPathExpr(variables, self.ownedBody.xmap toExprSingle(variables));
        };
    }
}

mapping IteratorExp::toReject(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredIteration.name = 'reject' }
{
    init {
        result := self.ownedSource.xmap toPathExpr(variables, self.ownedBody.xmap toExprSingle(variables).notExpr());
    }
}

// TODO: The mapping must return Expr
mapping OperationCallExp::toIncluding(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ParenthesizedExpr
when { self.referredOperation.name = 'including' }
{
    expr := object Expr {
        expr := self.ownedSource.xmap toExprSingle(variables);
        expr += self.ownedArguments.xmap toExprSingle(variables);
    };
}

query ExprSingle::booleanExpr() : FunctionCall = object FunctionCall { name := 'boolean'.createFunctionQName(); arg := self; };

query ExprSingle::notExpr() : ExprSingle =
    // Simplification: fn:not(fn:not(...)) = fn:boolean(...)
    if self.isFunctionCall('not'.createFunctionQName()) then
        self.oclAsType(FunctionCall).arg->collectOne(booleanExpr())
    // Simplification: fn:not(fn:boolean(...)) = fn:not(...)
    elif self.isFunctionCall('boolean'.createFunctionQName()) then
        self.oclAsType(FunctionCall).arg->collectOne(notExpr())
    // Simplification: fn:not(fn:not(...) and fn:not(...) and ...) = (... or ... or ...)
    elif self.oclIsKindOf(AndExpr) and self.oclAsType(AndExpr).operand->forAll(isFunctionCall('not'.createFunctionQName())) then
        object OrExpr { operand :=
            self.oclAsType(AndExpr).operand->collect(
                oclAsType(FunctionCall).arg->first().orExprOperand()) }
    // Simplification: fn:not(fn:not(...) or fn:not(...) or ...) = (... and ... and ...)
    elif self.oclIsKindOf(OrExpr) and self.oclAsType(OrExpr).operand->forAll(isFunctionCall('not'.createFunctionQName())) then
        object AndExpr { operand :=
            self.oclAsType(OrExpr).operand->collect(
                oclAsType(FunctionCall).arg->first().andExprOperand()) }
    // Simplification: fn:not(fn:exists(...)) = fn:empty(...)
    elif self.isFunctionCall('exists'.createFunctionQName()) then
        object FunctionCall { name := 'empty'.createFunctionQName(); arg := self.oclAsType(FunctionCall).arg; }
    // Simplification: fn:not(fn:empty(...)) = fn:exists(...)
    elif self.isFunctionCall('empty'.createFunctionQName()) then
        object FunctionCall { name := 'exists'.createFunctionQName(); arg := self.oclAsType(FunctionCall).arg; }
    else
        object FunctionCall { name := 'not'.createFunctionQName(); arg := self; }
    endif;

query ExprSingle::orExpr(rhs : ExprSingle) : ExprSingle
{
    var operands := self.orExprOperand();
    operands += rhs.orExprOperand();
    return
        // Simplification: fn:not(...) or fn:not(...) = fn:not(... and ...)
        if operands->forAll(isFunctionCall('not'.createFunctionQName())) then
            object AndExpr { operand :=
                operands->collect(
                    oclAsType(FunctionCall).arg->first().andExprOperand()) }.notExpr()
        else
            object OrExpr { operand := operands }
        endif;
}

query ExprSingle::orExprOperand() : OrderedSet(OrExprChild) =
    // Simplification: (... or ...) or ... = ... or ... or ...
    if self.oclIsKindOf(OrExpr) then
        self.oclAsType(OrExpr).operand
    // Simplification: fn:boolean(...) or ... = ... or ...
    elif self.isFunctionCall('boolean'.createFunctionQName()) then
        self.oclAsType(FunctionCall).arg
    // Simplification: (...) or ... = ... or ...
    elif self.oclIsKindOf(OrExprChild) then
        self.oclAsType(OrExprChild)->asOrderedSet()
    else
        object ParenthesizedExpr { expr := self }->asOrderedSet()
    endif;

query ExprSingle::andExprOperand() : OrderedSet(AndExprChild) =
    // Simplification: (... and ...) and ... = ... and ... and ...
    if self.oclIsKindOf(AndExpr) then
        self.oclAsType(AndExpr).operand
    // Simplification: fn:boolean(...) and ... = ... and ...
    elif self.isFunctionCall('boolean'.createFunctionQName()) then
        self.oclAsType(FunctionCall).arg
    // Simplification: (...) and ... = ... and ...
    elif self.oclIsKindOf(AndExprChild) then
        self.oclAsType(AndExprChild)->asOrderedSet()
    else
        object ParenthesizedExpr { expr := self }->asOrderedSet()
    endif;

//////////////////////////////////////////////////////////////////////////////
// Comparision

mapping OperationCallExp::toLeftNotNull(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.name = '<>' and self.ownedArguments->isNullLiteralExp() }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables);
    }
}

mapping OperationCallExp::toRightNotNull(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.name = '<>' and self.ownedSource.isNullLiteralExp() }
{
    init {
        result := self.ownedArguments->first().xmap toExprSingle(variables);
    }
}

mapping OperationCallExp::toComparisonExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ComparisonExpr
when { self.name.toGeneralComp() <> null and not(self.ownedSource.isNullLiteralExp() or self.ownedArguments->isNullLiteralExp()) }
{
    left := self.ownedSource.xmap toExprSingle(variables).comparisonExprChild();
    operator := object GeneralComp { operator := self.name.toGeneralComp() };
    right := self.ownedArguments->first().xmap toExprSingle(variables).comparisonExprChild();
}

query ExprSingle::comparisonExprChild() : ComparisonExprChild =
    // Simplification: (...) <> (...) = ... <> ...
    if self.oclIsKindOf(ComparisonExprChild) then
        self.oclAsType(ComparisonExprChild)
    else
        object ParenthesizedExpr { expr := self }
    endif;

query OCLExpression::isNullLiteralExp() : Boolean = self.oclIsKindOf(NullLiteralExp);

query OrderedSet(OCLExpression)::isNullLiteralExp() : Boolean =
    self->size() = 1 and self->first().oclIsKindOf(NullLiteralExp);

query String::toGeneralComp() : GeneralCompKind =
      if (self = "=")  then GeneralCompKind::eq
    elif (self = "<>") then GeneralCompKind::ne
    elif (self = "<")  then GeneralCompKind::lt
    elif (self = "<=") then GeneralCompKind::le
    elif (self = ">")  then GeneralCompKind::gt
    elif (self = ">=") then GeneralCompKind::ge
    endif;

//////////////////////////////////////////////////////////////////////////////
// Arithmetic

mapping OperationCallExp::toAdditiveExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : AdditiveExpr
when { self.name.toAdditiveOp() <> null }
{
    var lhs := self.ownedSource.xmap toExprSingle(variables).additiveExprOperand();
    var rhs := self.ownedArguments->first().xmap toExprSingle(variables).additiveExprOperand();
    operand := lhs.operand;
    operand += rhs.operand;
    operator := lhs.operator;
    operator += self.name.toAdditiveOp();
    operator += rhs.operator;
}

mapping OperationCallExp::toMultiplicativeExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : MultiplicativeExpr
when { self.name.toMultiplicativeOp() <> null }
{
    var lhs := self.ownedSource.xmap toExprSingle(variables).multiplicativeExprOperand();
    var rhs := self.ownedArguments->first().xmap toExprSingle(variables).multiplicativeExprOperand();
    operand := lhs.operand;
    operand += rhs.operand;
    operator := lhs.operator;
    operator += self.name.toMultiplicativeOp();
    operator += rhs.operator;
}

query ExprSingle::additiveExprOperand() : AdditiveExpr =
    // Simplification: (... + ...) - ... = ... + ... - ...
    if self.oclIsKindOf(AdditiveExpr) then
        self.oclAsType(AdditiveExpr)
    // Simplification: (...) + ... = ... + ...
    elif self.oclIsKindOf(AdditiveExprChild) then
        object AdditiveExpr { operand := self.oclAsType(AdditiveExprChild); }
    else
        object AdditiveExpr { operand := object ParenthesizedExpr { expr := self } }
    endif;

query ExprSingle::multiplicativeExprOperand() : MultiplicativeExpr =
    // Simplification: (... * ...) / ... = ... * ... / ...
    if self.oclIsKindOf(MultiplicativeExpr) then
        self.oclAsType(MultiplicativeExpr)
    // Simplification: (...) * ... = ... * ...
    elif self.oclIsKindOf(MultiplicativeExprChild) then
        object MultiplicativeExpr { operand := self.oclAsType(MultiplicativeExprChild); }
    else
        object MultiplicativeExpr { operand := object ParenthesizedExpr { expr := self } }
    endif;

query String::toAdditiveOp() : AdditiveOpKind =
      if (self = "+") then AdditiveOpKind::addition
    elif (self = "-") then AdditiveOpKind::subtraction
    endif;

query String::toMultiplicativeOp() : MultiplicativeOpKind =
      if (self = "*")   then MultiplicativeOpKind::multiplication
    elif (self = "/")   then MultiplicativeOpKind::div
    elif (self = "div") then MultiplicativeOpKind::idiv
    elif (self = "mod") then MultiplicativeOpKind::mod
    endif;

//////////////////////////////////////////////////////////////////////////////
// Cast

mapping OperationCallExp::toInteger(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : CastExpr
when { self.referredOperation.name = 'toInteger' }
{
    operand := self.ownedSource.xmap toExprSingle(variables).castExprOperand();
    type := 'integer'.createXSDType();
}

query ExprSingle::castExprOperand() : CastExprChild =
    // Simplification: (...) cast as ... = ... cast as ...
    if self.oclIsKindOf(CastExprChild) then
        self.oclAsType(CastExprChild)
    else
        object ParenthesizedExpr { expr := self }
    endif;

//////////////////////////////////////////////////////////////////////////////
// Path

// Self or iterator
mapping VariableExp::toPathExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : PathExpr
when { self.referredVariable[Variable]->one(name = 'self' or representedParameter <> null) }
{
    init {
        /*log('-->>>');
        variables->keys()->forEach (x) {
            log(x.toString() + ' ' + (x = self.referredVariable![Variable]).repr());
        };
        log('--<<<\n');*/
        if (variables->hasKey(self.referredVariable![Variable])) {
            result := variables->get(self.referredVariable![Variable]).deepclone().pathExpr();
        }
        else {
            // TODO: XPath must depend on current context
            result := object PathExpr {
                step := object SelfStepExpr {
                    step := object ContextItemExpr { };
                };
            };
        };
    }
}

// Declared variable
mapping VariableExp::toVarRef(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : PathExpr
when { self.referredVariable[Variable]->one(representedParameter = null) }
{
    init {
        var variable := variables->get(self.referredVariable![Variable]);
        assert fatal (variable.oclIsKindOf(VarRef)) with log ('Variable ' + self.referredVariable.toString() + ' not found');
        result := variable.deepclone().pathExpr();
    }
}

mapping PropertyCallExp::toPathExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : PathExpr
{
    init {
        // Flatten PropertyCallExp tree
        // VariableExp (self or iterator variable) is the innermost
        // component of an input tree, but it should be a first step
        // in an output path.
        result := self.ownedSource.xmap toExprSingle(variables).pathExpr();
    }

    //log('>>> ' + result.toString());
    // Steps must be created only for Data Types. Data Elements must be skipped
    //log('===' + self.repr());
    //log('>>>' + self.referredProperty.owningClass.repr());
    //log('>>>' + self.referredProperty.owningClass.isDataType().repr());
    //log(self.referredProperty.repr());
    //log(self.referredProperty.getETarget().repr());
    if (self.referredProperty.owningClass.isDataType()) {
        // Type can be a Set(T)
        var type := self.referredProperty.type.unwrap();

        assert fatal (type.oclIsKindOf(NamedElement)) with log('Property doesn\'t have a type');

        var element : NamedElement;
        // Property is local
        if (type.isDataType()) {
            element := self.referredProperty;
        }
        // Property is a reference to a global element or attribute
        elif (type.isDataElement()) {
            element := type;
        }
        else {
            assert fatal (false) with log('The property ' + self.toString() + ' must refer either type or element');
        };

        var stepItem : AbbrevForwardStep;
        if (self.referredProperty.isAttribute()) {
            stepItem := object AbbrevForwardStep {
                kind := AbbrevForwardStepKind::attribute;
                nodeTest := object QNameTest { name := element.getUnprefixedQName() };
            };
        }
        else {
            stepItem := object AbbrevForwardStep {
                kind := AbbrevForwardStepKind::child;
                nodeTest := object QNameTest { name := element.getQName() };
            };
        };
        //log('item : ' + stepItem.toString());

        // Simplification: ./path/... = path/...
        if (step->size() >= 1) {
            if (step->at(1)[SelfStepExpr].step->one(oclIsKindOf(ContextItemExpr))) {
                if (step->size() = 1) {
                    step := OrderedSet { };
                }
                else {
                    step := step->subOrderedSet(2, step->size());
                }
            }
        };

        /*log('>>>>>>>>');
        step->forEach (x) {
            log(x.repr());
        };
        log('<<<<<<<<');*/

        // TODO: The logic is too complex XPath metamodel must be refactored
        if (step->isEmpty() or step->size() = 1 and step->at(1).oclIsKindOf(RootStepExpr)) {
            step += object SelfStepExpr { step := stepItem };
        }
        else {
            step += object ChildStepExpr { step := stepItem };
        }
    }
    elif (self.referredProperty.owningClass.isDataElement()) {
    }
    else {
        assert fatal (false) with log(self.referredProperty.owningClass.name + ' must be either type or element');
    }
}

mapping OCLExpression::toPathExpr(variables : Dict(OCL::Variable, XPATH2::ExprSingle), predicate : ExprSingle) : PathExpr
{
    init {
        result := self.xmap toExprSingle(variables).pathExpr();
        result.getLastStepExpr().predicate += predicate.predicate();
    }
}

// TODO: Refactor it
// collect iteration indicates multivalued features. It must not be ignored.
mapping IteratorExp::toCollect(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : PathExpr
when { self.referredIteration.name = 'collect' }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables).pathExpr();
    }
    assert fatal (step->notEmpty());
    //log('>>>collect');
    // TODO: Pass current iterator variable?
    var body := self.ownedBody.xmap toExprSingle(variables).pathExpr();
    //log(' --- BODY: ' + self.ownedBody.repr());
    //log(' --- PATH: ' + body.toString());
    if (body.step->notEmpty()) {
        // TODO: It seems that there is a bug in the XPath metamodel.
        // SelfStepExpr may be only a first step in the path.
        // See concrete syntax for PathExpr.
        var firstStep := body.step->at(1);
        if (firstStep.oclIsKindOf(RootStepExpr)) {
            step += object ChildStepExpr {
                step := object FilterExpr {
                    primaryExpr := object ParenthesizedExpr {
                        expr := body;
                    };
                };
            };
        }
        elif (firstStep.oclIsKindOf(SelfStepExpr)) {
            if (step->size() = 1 and step->at(1).oclIsKindOf(RootStepExpr)) {
                step += firstStep;
            }
            else {
                step += object ChildStepExpr {
                    step := firstStep![SelfStepExpr].step;
                };
            };
            step += body.step->subOrderedSet(2, body.step->size());
        }
        else {
            step += body.step;
        }
    };
}

query AnyExpr::pathExpr() : PathExpr =
    if self.oclIsKindOf(PathExpr)
    then self.oclAsType(PathExpr)
    // TODO: The following logic is too complex, the XPath metamodel must be refactored
    else object PathExpr {
        step := object SelfStepExpr {
            if (self.oclIsKindOf(AxisStep)) {
                step := self.oclAsType(AxisStep);
            }
            else {
                step := object FilterExpr {
                    // Simplification: ((...)) = (...)
                    if (self.oclIsKindOf(FilterExprChild)) {
                        primaryExpr :=  self.oclAsType(FilterExprChild);
                    }
                    else {
                        primaryExpr :=  object ParenthesizedExpr { expr := self };
                    }
                }
            }
        }
    }
    endif;

query PathExpr::getLastStepExpr() : StepExpr
{
    assert fatal (self.step->notEmpty()) with log('Path doesn\'t contain steps');
    var lastStep = self.step->last();
    var axisStep : StepExpr;
    if (lastStep.oclIsKindOf(SelfStepExpr)) {
        axisStep := lastStep.oclAsType(SelfStepExpr).step.oclAsType(StepExpr);
    }
    elif (lastStep.oclIsKindOf(ChildStepExpr)) {
        axisStep := lastStep.oclAsType(ChildStepExpr).step.oclAsType(StepExpr);
    };
    assert fatal (axisStep <> null) with log('Last StepExpr not found in ' + self.toString());
    return axisStep;
}

query ExprSingle::predicate() : Predicate =
    object Predicate { expr :=
        // Simplification: ...[fn:boolean(...)] = ...[...]
        if self.isFunctionCall('boolean'.createFunctionQName()) then
            self.oclAsType(FunctionCall).arg->first()
        else
            self
        endif };

//////////////////////////////////////////////////////////////////////////////
// Functions

mapping OperationCallExp::toAsSet(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredOperation.name = 'oclAsSet' }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables);
    }
}

mapping OperationCallExp::toAsType(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredOperation.name = 'oclAsType' }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables);
    }
}
/*
mapping OperationCallExp::toAsTypePath(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : PathExpr
when { self.referredOperation.name = 'oclAsType' }
{
    init {
        //log('>>>');
        result := self.ownedSource.xmap toPathExpr(variables);
        //log(result.toString());
        //log('<<<');
    }
}
*/
mapping OperationCallExp::toDistinctValues(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'asSet' and self.ownedArguments->isEmpty() }
{
    name := 'distinct-values'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
}

mapping OperationCallExp::toCountFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'size' and self.referredOperation.isCollectionOperation() }
{
    name := 'count'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
}

mapping OperationCallExp::toIncludesFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'includes' and self.referredOperation.isCollectionOperation() }
{
    name := 'exists'.createFunctionQName();
    arg := self.xmap toIndexOfFunctionCall(variables);
}

mapping OperationCallExp::toIndexOfFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
{
    name := 'index-of'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
    arg += self.ownedArguments->toExprSingle(variables);
}

mapping OperationCallExp::toStringLengthFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'size' and not self.referredOperation.isCollectionOperation() }
{
    name := 'string-length'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
}

mapping OperationCallExp::toIsEmpty(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredOperation.name = 'isEmpty' }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables).notExpr();
    }
}

mapping OperationCallExp::toNotEmpty(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'notEmpty' }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables).booleanExpr();
    }
}

mapping OperationCallExp::toSubstring(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'substring' }
{
    assert fatal (self.ownedArguments->size() = 2);
    assert fatal (self.ownedArguments->forAll(oclIsKindOf(IntegerLiteralExp)));
    var startPos := self.ownedArguments[IntegerLiteralExp]->at(1).getValue();
    var endPos := self.ownedArguments[IntegerLiteralExp]->at(2).getValue();
    assert fatal (startPos <= endPos);
    name := 'substring'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
    arg += object IntegerLiteral {
        value := startPos;
    };
    arg += object IntegerLiteral {
        value := endPos - startPos + 1;
    };
}

mapping OperationCallExp::toMatches(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'matches' and self.ownedArguments->one(oclIsKindOf(StringLiteralExp)) }
{
    name := 'matches'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
    arg += self.ownedArguments->toExprSingle(variables);
}

mapping OperationCallExp::toReplaceAll(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'replaceAll' and self.ownedArguments->size() = 2 and self.ownedArguments->forAll(oclIsKindOf(StringLiteralExp)) }
{
    name := 'replace'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
    arg += self.ownedArguments->toExprSingle(variables);
}

mapping OperationCallExp::toCodePoints(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'toCodePoints' and self.ownedArguments->isEmpty() }
{
    name := 'string-to-codepoints'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
}

mapping OperationCallExp::toSumFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'sum' and self.referredOperation.isCollectionOperation() }
{
    name := 'sum'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
}

mapping IteratorExp::toIsUnique(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredIteration.name = 'isUnique' }
{
    init {
        var nodesPath := self.ownedBody.xmap toExprSingle(variables);
        var predicate := object ComparisonExpr {
            left := object FunctionCall {
                name := 'count'.createFunctionQName();
                arg := object FunctionCall {
                    name := 'distinct-values'.createFunctionQName();
                    arg := nodesPath;
                };
            };
            operator := object GeneralComp { operator := GeneralCompKind::eq };
            right := object FunctionCall {
                name := 'count'.createFunctionQName();
                arg := nodesPath.deepclone();
            }
        };
        result := self.ownedSource.xmap toPathExpr(variables, predicate).booleanExpr();
    }
}

mapping OperationCallExp::toHasTimezoneFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'hasTimezone' }
{
    name := 'exists'.createFunctionQName();
    arg := self.xmap toGetTimezoneFunctionCall(variables);
}

mapping OperationCallExp::toGetTimezoneFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
disjuncts
    OperationCallExp::toGetTimezoneFromDateTimeFunctionCall,
    OperationCallExp::toGetTimezoneFromDateFunctionCall,
    OperationCallExp::toGetTimezoneFromTimeFunctionCall
{
}

mapping OperationCallExp::toGetTimezoneFromDateTimeFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'hasTimezone' and self.referredOperation.owningClass.isDateTimeType() }
{
    name := 'timezone-from-dateTime'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
}

mapping OperationCallExp::toGetTimezoneFromDateFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'hasTimezone' and self.referredOperation.owningClass.isDateType() }
{
    name := 'timezone-from-date'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
}

mapping OperationCallExp::toGetTimezoneFromTimeFunctionCall(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredOperation.name = 'hasTimezone' and self.referredOperation.owningClass.isTimeType() }
{
    name := 'timezone-from-time'.createFunctionQName();
    arg := self.ownedSource.xmap toExprSingle(variables);
}

mapping OperationCallExp::toNewDuration(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredOperation.name = 'new' and self.referredOperation.owningClass.isDurationType() }
{
    init {
        result := self.ownedArguments->asSequence()->at(1).xmap toExprSingle(variables);
    }
}

mapping OperationCallExp::toDateCast(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredOperation.name = 'toDate' and self.referredOperation.owningClass.isDateTimeType() }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables);
    }
}

// TODO: It returns duration without any change, but must return working days duration
mapping OperationCallExp::toGetWorkingDays(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
when { self.referredOperation.name = 'getWorkingDays' and self.referredOperation.owningClass.isDurationType() }
{
    init {
        result := self.ownedSource.xmap toExprSingle(variables);
    }
}

//////////////////////////////////////////////////////////////////////////////
// Literals

mapping IntegerLiteralExp::toLiteral(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : IntegerLiteral
{
    value := self.integerSymbol.oclAsType(Integer);
}

mapping UnlimitedNaturalLiteralExp::toLiteral(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : IntegerLiteral
{
    value := self.unlimitedNaturalSymbol.oclAsType(Integer);
}

mapping RealLiteralExp::toLiteral(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : NumericLiteral
{
    init {
        var val := self.realSymbol.repr().toReal();
        result := if (val.repr().matches('.+[eE].+'))
            then object DoubleLiteral { value := val }
            else object DecimalLiteral { value := val } endif;
    }
}

mapping StringLiteralExp::toLiteral(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : StringLiteral
{
    // TODO: It must be quoted by the string literal resolver in the XPath project
    value := self.stringSymbol.quote();
}

mapping BooleanLiteralExp::toLiteral(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
{
    name := if self.booleanSymbol then 'true' else 'false' endif.createFunctionQName();
}

// TODO: Return type must be Expr? ParenthesizedExpr is added if necessary.
mapping CollectionLiteralExp::toSequence(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ParenthesizedExpr
{
    assert fatal (self.ownedParts->forAll(oclIsKindOf(CollectionItem))) with log ('Only CollectionItem supported');
    expr := object Expr {
        expr := self.ownedParts[CollectionItem].ownedItem->toExprSingle(variables)
    };
}

//////////////////////////////////////////////////////////////////////////////
// External expressions

mapping IteratorExp::toExternalExists(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : FunctionCall
when { self.referredIteration.name = 'exists' and self.isExternal() }
{
    name := createQName('urn:external-functions', 'exists', 'ext');
    arg := object StringLiteral {
        // TODO: It must be quoted by the string literal resolver in the XPath project
        value := self.ownedSource![OperationCallExp].ownedSource.oclAsType(TypeExp).referredType.name.quote();
    };
    var variables2 := variables;
    //self.ownedBody.
    arg += object StringLiteral {
        value := self.ownedBody.xmap toExprSingle(variables2).toString().quote();
    };
}

//////////////////////////////////////////////////////////////////////////////
// Unknown expressions

mapping OCLExpression::raiseError(variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : PathExpr
{
    assert fatal (false) with log('Not implemented for ' + self.metaClassName() + ' (' + self.repr() + ')');
}

//////////////////////////////////////////////////////////////////////////////
// Helpers

query OCLExpression::isExternal() : Boolean =
    assert fatal (false) with log('Not implemented for ' + self.metaClassName() + ' (' + self.repr() + ')');

query LiteralExp::isExternal() : Boolean = false;

query VariableExp::isExternal() : Boolean = false;

query LetExp::isExternal() : Boolean =
    self.ownedVariable.ownedInit.isExternal() or self.ownedIn.isExternal();

query PropertyCallExp::isExternal() : Boolean = false;

query OperationCallExp::isExternal() : Boolean =
    self.ownedSource.isExternal() or self.ownedArguments->exists(isExternal());

query IteratorExp::isExternal() : Boolean =
    self.ownedSource[OperationCallExp]->one(referredOperation.name = 'allInstances' and ownedSource.oclIsKindOf(TypeExp));


query OCLExpression::findNestedIteratorExps() : Set(IteratorExp) =
    assert fatal (false) with log('Not implemented for ' + self.metaClassName() + ' (' + self.repr() + ')');

query LiteralExp::findNestedIteratorExps() : Set(IteratorExp) = Set {};

query TypeExp::findNestedIteratorExps() : Set(IteratorExp) = Set {};

query VariableExp::findNestedIteratorExps() : Set(IteratorExp) = Set {};

query PropertyCallExp::findNestedIteratorExps() : Set(IteratorExp) = Set {};

query OperationCallExp::findNestedIteratorExps() : Set(IteratorExp) =
    self.ownedSource.findNestedIteratorExps()->union(
        self.ownedArguments.findNestedIteratorExps()->asSet());

query IteratorExp::findNestedIteratorExps() : Set(IteratorExp) = Set { self };


query OCLExpression::hasReferenceTo(variable : OCL::Variable) : Boolean =
    assert fatal (false) with log('Not implemented for ' + self.metaClassName() + ' (' + self.repr() + ')');

query LiteralExp::hasReferenceTo(variable : OCL::Variable) : Boolean = false;

query TypeExp::hasReferenceTo(variable : OCL::Variable) : Boolean = false;

query VariableExp::hasReferenceTo(variable : OCL::Variable) : Boolean =
    self.referredVariable = variable;

query PropertyCallExp::hasReferenceTo(variable : OCL::Variable) : Boolean =
    self.ownedSource.hasReferenceTo(variable);

query OperationCallExp::hasReferenceTo(variable : OCL::Variable) : Boolean =
    self.ownedSource.hasReferenceTo(variable) or
    self.ownedArguments->forAll(hasReferenceTo(variable));

query IteratorExp::hasReferenceTo(variable : OCL::Variable) : Boolean =
    self.ownedSource.hasReferenceTo(variable) or
    self.ownedBody->forAll(hasReferenceTo(variable));


query NamedElement::unwrap() : NamedElement =
    if self.oclIsKindOf(SetType) then self.oclAsType(SetType).elementType else self endif;

query NamedElement::getQName() : QName = self.getETarget().getQName();

query NamedElement::getUnprefixedQName() : QName = self.getETarget().getUnprefixedQName();

query NamedElement::isDataType() : Boolean = self.getETarget().isDataType();

query NamedElement::isDateType() : Boolean = self.getETarget().isDateType();

query NamedElement::isDateTimeType() : Boolean = self.getETarget().isDateTimeType();

query NamedElement::isTimeType() : Boolean = self.getETarget().isTimeType();

query NamedElement::isDurationType() : Boolean = self.getETarget().isDurationType();

query NamedElement::isDataElement() : Boolean = self.getETarget().isDataElement();

query Property::isAttribute() : Boolean = self.getETarget().isAttribute();

query Operation::isBooleanOperation(name : String) : Boolean =
    self.owningClass.oclIsKindOf(PrimitiveType) and
    self.owningClass.name = 'Boolean' and
    self.name = name;

query Operation::isCollectionOperation() : Boolean =
    self.owningClass.oclIsKindOf(CollectionType);

query ExprSingle::isFunctionCall(name : QName) : Boolean =
    self.oclIsKindOf(FunctionCall) and self.oclAsType(FunctionCall).name = name;

query String::createXSDType() : SingleType =
    object SingleType {
        type := object AtomicType {
            name := createQName('http://www.w3.org/2001/XMLSchema', self, 'xs');
        };
    };

query String::createFunctionQName() : QName =
    createQName('http://www.w3.org/2005/xpath-functions', self, 'fn');
