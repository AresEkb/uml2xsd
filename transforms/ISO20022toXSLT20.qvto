/**
 * Copyright (c) 2015, 2016 Denis Nikiforov.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Denis Nikiforov - initial API and implementation
 */

/**
 * Types, elements and other objects may be duplicated in several output schemas.
 * So we pass root of the output schema as additional mapping argument to generate duplicate objects.
 */

import ISO20022Helpers;
import OCLtoXPath;
import DocOCL;

modeltype UML uses 'http://www.eclipse.org/uml2/2.1.0/UML';
modeltype OCL 'strict' uses 'http://www.eclipse.org/ocl/2015/Pivot';
modeltype XSLT uses 'http://www.w3.org/1999/XSL/Transform';
modeltype XPATH2 'strict' uses 'http://www.emftext.org/language/xpath2';
modeltype ECORE uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype TYPE uses 'http://www.eclipse.org/emf/2003/XMLType';

transformation ISO20022toXSLT20(in m : UML, out x : XSLT);

configuration property noNamespace : Boolean;

main()
{
    if (noNamespace.oclIsUndefined()) {
        noNamespace := false;
    };
    m.objectsOfKind(Classifier)->select(is('MessageDefinition'))->toStylesheet();
    m.objectsOfKind(Classifier)->select(is('MessageDefinition'))->toStylesheetForHTML();
}

mapping Classifier::toStylesheet() : DocumentRoot
{
    var msgId := self.getValue(profileName + '::MessageDefinition', 'messageDefinitionIdentifier');
    var namespace := 'urn:iso:std:iso:20022:tech:xsd:' + msgId.replaceAll('-.*$', '');

    log('  Found message ' + msgId);

    var stylesheetObj := object TransformType {
        id := msgId;
        version := 2;
        if (not noNamespace) {
            xpathDefaultNamespace := namespace;
        };
        excludeResultPrefixes := PrefixListOrAllMember1::all;
    };

    stylesheetObj._import := object ImportType {
        href := 'iso20022-validation.xsl';
    };

    var rootPathExpr := self.getRootPath();

    var props := self.allAttributes()->closure(type.oclAsType(Classifier).allAttributes())->union(self.allAttributes());

    object XMLTypeDocumentRoot {};
    stylesheetObj.declarationGroup := object VariableType {
        name := 'elementNames';
        as := 'item()*';
        select := 'fn:doc(\'' + msgId + '-metadata.xml\')';
    }->toFMEntry('variable');

    stylesheetObj.declarationGroup += self->closure(attribute.type[Classifier])->including(self)->sortedBy(name)->
        //select(ownedRule->exists(not isExternal()))->
        select(ownedRule->notEmpty())->
        toTemplate(stylesheetObj, rootPathExpr, props)->toFMEntry('template');

//    stylesheetObj.declarationGroup := self->closure(attribute.type[Classifier])->including(self).
//        ownedRule->sortedBy(name)->
//        toTemplate2(stylesheetObj, rootPathExpr, props)->toFMEntry('template');

    stylesheet := stylesheetObj;

    xMLNSPrefixMap += resolveIn(ExprSingle::findQNames, StylesheetQNames)
        ->select(stylesheet=stylesheetObj).qnames
        ->collect(qname|object EStringToStringMapEntry {
            key := qname.getPrefix();
            value := qname.getNamespaceURI();
        });
}

mapping Classifier::toStylesheetForHTML() : DocumentRoot
{
    var msgId := self.getValue(profileName + '::MessageDefinition', 'messageDefinitionIdentifier');
    var namespace := 'urn:iso:std:iso:20022:tech:xsd:' + msgId;

    log('  Generating HTML version of XSLT for message ' + msgId);

    var stylesheetObj := object TransformType {
        id := msgId + '-html';
        version := 2;
        xpathDefaultNamespace := namespace;
        excludeResultPrefixes := PrefixListOrAllMember1::all;
    };

    stylesheetObj._import := object ImportType {
        href := msgId + '.xsl';
    };
    stylesheetObj._import += object ImportType {
        href := 'iso20022-validation-html.xsl';
    };

    stylesheet := stylesheetObj;
}

mapping NamedElement::toPathExpr(stylesheet : TransformType, rootPathExpr : PathExpr, props : Set(Property)) : Set(PathExpr)
{
    init {
        var currentType := if self.oclIsKindOf(Type) then self else self.owner endif;
        var parents := props->select(type = currentType);
        if (currentType.oclIsKindOf(Signal) or parents->isEmpty()) {
            result += rootPathExpr.deepclone().oclAsType(PathExpr);
        }
        else {
            result := parents.xmap toPathExpr(stylesheet, rootPathExpr, props).deepclone()[PathExpr]->asSet();
        };
    }
    if (self.oclIsKindOf(Property)) {
        result->forEach (path) {
            path.step += object ChildStepExpr {
                step := object AbbrevForwardStep {
                    kind := AbbrevForwardStepKind::child;
                    nodeTest := object QNameTest { name := self.getQName() };
                };
            };
        };
    }
}

-- The mapping is called for each type which has rules.
mapping Classifier::toTemplate(stylesheet : TransformType, rootPathExpr : PathExpr, props : Set(Property)) : TemplateType
{
    var contexts := self.xmap toPathExpr(stylesheet, rootPathExpr, props);
    if (contexts->isEmpty()) {
        contexts += object PathExpr {
            step := object RootStepExpr { };
        };
    };
    var context := object UnionExpr {
        operand := contexts->sortedBy(toString());
        operation := Sequence{1..operand->size()-1}->collect(UnionOp::vertical_bar);
    };
    context.xmap findQNames(stylesheet);
    match := context.toString();

    instructionGroup += object VariableType {
        name := '__context';
        select := '.';
    }->toFMEntry('variable');

    self.ownedRule->
        collect(c | Tuple { constraint = c, rule = c.xmap toRule() })->
        select(notEmpty(rule.name))->sortedBy(rule.name)->forEach (c)
    {
        log('    Found rule ' + c.rule.name);
        var validationStatements : Sequence(EFeatureMapEntry);
        try {
            validationStatements := c.constraint.xmap toInstructionGroup(stylesheet);
        }
        except () {
            log('WARNING: Unable to generate validation code');
        };
        if (validationStatements->notEmpty()) {
            instructionGroup += validationStatements;
        }
        else {
            instructionGroup += object CommentType {
                text := 'Rule ' + c.rule.name + ' is unsupported';
            }->toFMEntry('comment');
        }
    };

    instructionGroup += object ApplyTemplatesType { }.toFMEntry('applyTemplates');
}

mapping Constraint::toInstructionGroup(stylesheet : TransformType) : Sequence(EFeatureMapEntry)
{
    init {
        var exprInOCL := self.toExpressionInOCL();
        var expr := exprInOCL.ownedBody;
        var variables : Dict(OCL::Variable, XPATH2::ExprSingle);

        if (not expr.isExternal()) {
            variables->put(exprInOCL.ownedContext, object VarRef { varName := createQName('__context') });

            if (expr.isLet()) {
                var variable := expr![LetExp].ownedVariable;
                var variableName := (self.name + '_' + variable.name).toIdentifier();
                expr := expr![LetExp].ownedIn;
                variables->put(variable, object VarRef { varName := createQName(variableName) });
                result += object VariableType {
                    name := variableName;
                    try {
                        var variableInit := variable.ownedInit.xmap toExprSingle(variables);
                        select := variableInit.toString();
                    }
                    except () {
                        log('WARNING: Unable to transform init expression for variable ' + variableName);
                    }
                }->toFMEntry('variable');
            };

            if (expr.isForAll()) {
                result += self->toForEach(stylesheet, self![IteratorExp].ownedIterators->first(), expr, variables)->toFMEntry('forEach');
            }
            else {
                result += self->toValidate(stylesheet, exprInOCL.ownedContext, expr, variables)->toFMEntry('callTemplate');
            }
        }
    }
}

mapping OCLExpression::toXPath(stylesheet : TransformType, variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ExprSingle
{
    init {
        //try {
            //log('    Transforming OCL expression\n      ' + self.toString());
            result := self.xmap toExprSingle(variables);
            //log('    to\n      ' + result.toString());
        //}
        //except () {
        //    log('WARNING: Unable to transform expression');
        //    result := object FunctionCall { name := 'true'.createFunctionQName() };
        //};
    }
    result.xmap findQNames(stylesheet);
}

query String::toMessage(stylesheet : TransformType, context : OCL::Type, variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : Sequence(EFeatureMapEntry) =
    self.tokenizeDocOCL()->collect(token|
        if token.isExpr then
            object ValueOfType {
                select := token.text.toExpressionInOCL(context).ownedBody.xmap toXPath(stylesheet, variables).toString();
            }->toFMEntry('valueOf')
        else
            object TextType {
                value := token.text;
            }->toFMEntry('text')
        endif);

mapping Constraint::toValidate(
    stylesheet : TransformType,
    context : OCL::Variable,
    expr : OCLExpression,
    variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : CallTemplateType
{
    name := 'validate';

    var rule := self.xmap toRule();

    withParam += object WithParamType {
        name := 'code';
        text := rule.name;
    };
    withParam += object WithParamType {
        name := 'isValid';
        select := expr.xmap toXPath(stylesheet, variables).toString();
    };
    withParam += object WithParamType {
        name := 'definition';
        text := rule.description;
    };
    withParam += object WithParamType {
        name := 'ocl';
        text := rule.ocl;
    };
    withParam += object WithParamType {
        name := 'error';
        mixed := rule.errorMessage.toMessage(stylesheet, context.type, variables);
    };
    if (notEmpty(rule.successMessage)) {
        withParam += object WithParamType {
            name := 'valid';
            mixed := rule.successMessage.toMessage(stylesheet, context.type, variables);
        };
    };
}

mapping Constraint::toForEach(
    stylesheet : TransformType,
    context : OCL::Variable,
    expr : OCLExpression,
    variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ForEachType
{
    var iterator := expr.oclAsType(IteratorExp);
    var xpath : ExprSingle;
    try {
        xpath := iterator.ownedSource.xmap toExprSingle(variables);
    }
    except () {
        log('WARNING: Unable to transform expression');
        xpath := object ParenthesizedExpr { };
    };
    xpath.xmap findQNames(stylesheet);
    select := xpath.toString();

    var variables2 : Dict(OCL::Variable, XPATH2::ExprSingle);
    variables->keys()->forEach (key) {
        variables2->put(key, variables->get(key));
    };
    variables2->put(iterator.ownedIterators->any(true), object FunctionCall { name := createQName('current') });

    instructionGroup += self->toValidate(stylesheet, iterator.ownedIterators->any(true), iterator.ownedBody, variables2)->toFMEntry('callTemplate');
}

intermediate class StylesheetQNames { stylesheet : TransformType; qnames : Set(TYPE::QName); };

mapping ExprSingle::findQNames(currentStylesheet : TransformType) : StylesheetQNames
{
    stylesheet := currentStylesheet;
    qnames := self.allSubobjects()[EObject]->
        collect(obj|obj.eClass().eAttributes->collect(attr|obj.eGet(attr)))[TYPE::QName]->
        select(getPrefix() <> null and getNamespaceURI() <> null)->asSet();
}

///////////////////////////////////////////////////////////////////////////////
// Helpers

query GenericElementType::toFMEntry(name : String) : EFeatureMapEntry =
    createFeatureMapEntry('http://www.w3.org/1999/XSL/Transform', name, self);

// TODO: Constraints must be parsed only once
//query Constraint::isSupported() : Boolean =
//    self.toExpressionInOCL().ownedBody.isSupported();

//query OCLExpression::isSupported() : Boolean =
//    if self.oclIsKindOf(OperationCallExp) then self![OperationCallExp]->forAll(
//        referredOperation.name <> 'allInstances' and ownedSource.isSupported() and ownedArguments->forAll(isSupported()))
//    elif self.oclIsKindOf(IteratorExp) then self![IteratorExp]->forAll(
//        ownedSource.isSupported() and ownedBody->forAll(isSupported()))
//    else true endif;
