/**
 * Copyright (c) 2015 Denis Nikiforov.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *    Denis Nikiforov - initial API and implementation
 */

/**
 * Types, elements and other objects may be duplicated in several output schemas.
 * So we pass root of the output schema as additional mapping argument to generate duplicate objects.
 */

import uml2xsd.UtilitiesLibrary;
import OCLtoXPath;

modeltype UML uses 'http://www.eclipse.org/uml2/2.1.0/UML';
modeltype OCL 'strict' uses 'http://www.eclipse.org/ocl/2015/Pivot';
modeltype XSLT uses 'http://www.w3.org/1999/XSL/Transform';
modeltype VR uses 'urn:iso20022:validation:result';
modeltype XPATH2 'strict' uses 'http://www.emftext.org/language/xpath2';
modeltype ECORE uses 'http://www.eclipse.org/emf/2002/Ecore';
modeltype TYPE uses 'http://www.eclipse.org/emf/2003/XMLType';

transformation ISO20022toXSLT20(in m : UML, out x : XSLT)
    extends OCLtoXPath;

property profileName : String = 'ISO20022Profile';

main()
{
    m.objectsOfKind(Classifier)->select(is('MessageDefinition'))->toStylesheet();
    m.objectsOfKind(Classifier)->select(is('MessageDefinition'))->toStylesheetForHTML();
}

mapping Classifier::toStylesheet() : DocumentRoot
{
    var msgId := self.getValue(profileName + '::MessageDefinition', 'messageDefinitionIdentifier');
    var namespace := 'urn:iso:std:iso:20022:tech:xsd:' + msgId.replaceAll('-.*$', '');
    
    log('  Found message ' + msgId);

    var stylesheetObj := object TransformType {
        id := msgId;
        version := 2;
        xpathDefaultNamespace := namespace;
        excludeResultPrefixes := PrefixListOrAllMember1::all;
    };

    stylesheetObj._import := object ImportType {
    	href := 'iso20022-validation.xsl';
    };

    var rootPathExpr := object PathExpr {
        step := object RootStepExpr { };
        step += object AbbrevForwardStep {
            kind := AbbrevForwardStepKind::child;
            nodeTest := object QNameTest { name := createQName('Document') };
        };
        step += object ChildStepExpr {
            step := object AbbrevForwardStep {
                kind := AbbrevForwardStepKind::child;
                nodeTest := object QNameTest { name := self.getQName() };
            };
        };
    };

    var props := self.allAttributes()->closure(type.oclAsType(Classifier).allAttributes())->union(self.allAttributes());

    stylesheetObj.declarationGroup := self->closure(attribute.type[Classifier])->including(self)->sortedBy(name)->
        //select(ownedRule->exists(isSupported()))->
        select(ownedRule->notEmpty())->
        toTemplate(stylesheetObj, rootPathExpr, props)->toFMEntry('template');

//    stylesheetObj.declarationGroup := self->closure(attribute.type[Classifier])->including(self).
//        ownedRule->sortedBy(name)->
//        toTemplate2(stylesheetObj, rootPathExpr, props)->toFMEntry('template');

    stylesheet := stylesheetObj;

    xMLNSPrefixMap += resolveIn(ExprSingle::findQNames, StylesheetQNames)
        ->select(stylesheet=stylesheetObj).qnames
        ->collect(qname|object EStringToStringMapEntry {
            key := qname.getPrefix();
            value := qname.getNamespaceURI();
        });
}

mapping Classifier::toStylesheetForHTML() : DocumentRoot
{
    var msgId := self.getValue(profileName + '::MessageDefinition', 'messageDefinitionIdentifier');
    var namespace := 'urn:iso:std:iso:20022:tech:xsd:' + msgId;
    
    log('  Generating HTML version of XSLT for message ' + msgId);

    var stylesheetObj := object TransformType {
        id := msgId + '-html';
        version := 2;
        xpathDefaultNamespace := namespace;
        excludeResultPrefixes := PrefixListOrAllMember1::all;
    };

    stylesheetObj._import := object ImportType {
        href := msgId + '.xsl';
    };
    stylesheetObj._import += object ImportType {
        href := 'iso20022-validation-html.xsl';
    };

    stylesheet := stylesheetObj;
}

mapping NamedElement::toPathExpr(stylesheet : TransformType, rootPathExpr : PathExpr, props : Set(Property)) : Set(PathExpr)
{
    init {
        var currentType := if self.oclIsKindOf(Type) then self else self.owner endif;
        var parents := props->select(type = currentType);
        if (currentType.oclIsKindOf(Signal) or parents->isEmpty()) {
            result += rootPathExpr.deepclone().oclAsType(PathExpr);
        }
        else {
            result := parents.xmap toPathExpr(stylesheet, rootPathExpr, props).deepclone()[PathExpr]->asSet();
        };
    }
    if (self.oclIsKindOf(Property)) {
        result->forEach (path) {
            path.step += object ChildStepExpr {
                step := object AbbrevForwardStep {
                    kind := AbbrevForwardStepKind::child;
                    nodeTest := object QNameTest { name := self.getQName() };
                };
            };
        };
    }
}

-- The mapping is called for each type which has rules.
mapping Classifier::toTemplate(stylesheet : TransformType, rootPathExpr : PathExpr, props : Set(Property)) : TemplateType
{
    var contexts := self.xmap toPathExpr(stylesheet, rootPathExpr, props);
    if (contexts->isEmpty()) {
    	contexts += object PathExpr {
            step := object RootStepExpr { };
        };
    };
    var context := object UnionExpr {
        operand := contexts->sortedBy(toString());
        operation := Sequence{1..operand->size()-1}->collect(UnionOp::vertical_bar);
    };
    context.xmap findQNames(stylesheet);
    match := context.toString();

    self.ownedRule->sortedBy(name)->forEach (rule) {
        var expr : OCLExpression;
        try {
            expr := rule.toExpressionInOCL().ownedBody;
        }
        except () {
            log('WARNING: Unable to parse expression');
            expr := object BooleanLiteralExp { booleanSymbol := true };
        };

        var variables : Dict(OCL::Variable, XPATH2::ExprSingle);

        if (expr.isLet()) {
            var variable := expr![LetExp].ownedVariable;
            var variableName := rule.name + '_' + variable.name;
            expr := expr![LetExp].ownedIn;
            variables->put(variable, object VarRef { varName := createQName(variableName) });
            instructionGroup += object VariableType {
            	name := variableName;
            	try {
            	    var variableInit := variable.ownedInit.xmap toExprSingle(variables);
            	    select := variableInit.toString();
            	}
            	except () {
                    log('WARNING: Unable to transform init expression for variable ' + variableName);
            	}
            }->toFMEntry('variable');
        };
        
        if (expr.isForAll()) {
            instructionGroup += rule->toForEach(stylesheet, expr, variables)->toFMEntry('forEach');
        }
        else {
            instructionGroup += rule->toIf(stylesheet, expr, variables)->toFMEntry('if');
        };
    };
    instructionGroup += object ApplyTemplatesType { }.toFMEntry('applyTemplates');
}

query OCLExpression::isForAll() : Boolean =
    self.oclIsKindOf(IteratorExp) and
    self![IteratorExp].referredIteration.name = 'forAll';

query OCLExpression::isLet() : Boolean =
    self.oclIsKindOf(LetExp);

mapping Constraint::toIf(stylesheet : TransformType, expr : OCLExpression, variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : IfType
{
    var xpath : ExprSingle;
    try {
        log('    Transforming OCL expression\n      ' + expr.toString());
        xpath := expr.xmap toExprSingle(variables).notExpr();
        log('    to\n      ' + xpath.toString());
    }
    except () {
        log('WARNING: Unable to transform expression');
        xpath := object FunctionCall { name := 'false'.createFunctionQName() };
    };
    xpath.xmap findQNames(stylesheet);
    test := xpath.toString();

    mixed := createFeatureMapEntry('urn:iso20022:validation:result', 'error', object ErrorType {
        ruleName := object AnyContentType {
            text := self.name;
        };
        element := genPath();
        message := object AnyContentType {
            text := self.specification[OpaqueExpression].body->any(true);
        };
    });
}

mapping Constraint::toForEach(stylesheet : TransformType, expr : OCLExpression, variables : Dict(OCL::Variable, XPATH2::ExprSingle)) : ForEachType
{
    var iterator := expr.oclAsType(IteratorExp);
    var xpath : ExprSingle;
    try {
        xpath := iterator.ownedSource.xmap toExprSingle(variables);
    }
    except () {
        log('WARNING: Unable to transform expression');
        xpath := object ParenthesizedExpr { };
    };
    xpath.xmap findQNames(stylesheet);
    select := xpath.toString();
    instructionGroup += self->toIf(stylesheet, iterator.ownedBody, variables)->toFMEntry('if');
}

intermediate class StylesheetQNames { stylesheet : TransformType; qnames : Set(TYPE::QName); };

mapping ExprSingle::findQNames(currentStylesheet : TransformType) : StylesheetQNames
{
    stylesheet := currentStylesheet;
    qnames := self.allSubobjects()[EObject]->
        collect(obj|obj.eClass().eAttributes->collect(attr|obj.eGet(attr)))[TYPE::QName]->
        select(getPrefix() <> null and getNamespaceURI() <> null)->asSet();
}

///////////////////////////////////////////////////////////////////////////////
// Helpers

query GenericElementType::toFMEntry(name : String) : EFeatureMapEntry =
    createFeatureMapEntry('http://www.w3.org/1999/XSL/Transform', name, self);

query genPath() : AnyContentType =
    object AnyContentType {
        mixed := object CallTemplateType { name := 'genPath'; }.toFMEntry('callTemplate');
    };

query NamedElement::generateXMLTag() : String
{
    var name : String;
    //log(self.repr());
    if (self.is('MessageDefinition')) {
        name := self.getValue(profileName + '::MessageDefinition', 'xmlTag');
        //log('!!!' + name);
    }
    elif (self.is('MessageBuildingBlock')) {
        name := self.getValue(profileName + '::MessageBuildingBlock', 'xmlTag');
    }
    elif (self.is('MessageElement')) {
        name := self.getValue(profileName + '::MessageElement', 'xmlTag');
    }
    else {
        name := self.name;
        if (name.lastIndexOf('.') > 0) {
            name := name.substring(1, name.lastIndexOf('.'));
        };
        name := name.replaceFirst('V\\d+$', '');
        // TODO http://www.iso20022.org/documents/general/XML_Tag_algorithm.pdf
    };

    assert fatal (name <> null and name.size() > 0) with log('For element ' + self.getNameWithStereotypes() + ' generated empty xmlTag');
    
    return name;
}

// TODO: Constraints must be parsed only once
//query Constraint::isSupported() : Boolean =
//    self.toExpressionInOCL().ownedBody.isSupported();

//query OCLExpression::isSupported() : Boolean =
//    if self.oclIsKindOf(OperationCallExp) then self![OperationCallExp]->forAll(
//        referredOperation.name <> 'allInstances' and ownedSource.isSupported() and ownedArguments->forAll(isSupported()))
//    elif self.oclIsKindOf(IteratorExp) then self![IteratorExp]->forAll( 
//        ownedSource.isSupported() and ownedBody->forAll(isSupported()))
//    else true endif;

///////////////////////////////////////////////////////////////////////////////
// Overrides

// TODO: OCLtoXPath uses both prefixed and unprefixed names. Something must be refactored.
query NamedElement::getQName() : TYPE::QName =
    self.getUnprefixedQName();
//    assert fatal (false) with log('NamedElement::getQName() must not be used');

query NamedElement::getUnprefixedQName() : TYPE::QName =
    createQName(self.generateXMLTag()).oclAsType(TYPE::QName);

query Element::is(stereotypeName : String) : Boolean = self.is(profileName, stereotypeName);

query NamedElement::isDataType() : Boolean = self.oclIsKindOf(Classifier);

query NamedElement::isDateType() : Boolean =
    if self.oclIsKindOf(Classifier)
    then self.oclAsType(Classifier).allParents()->including(self.oclAsType(Classifier))->exists(name = 'Date')
    else false endif;

query NamedElement::isDateTimeType() : Boolean =
    if self.oclIsKindOf(Classifier)
    then self.oclAsType(Classifier).allParents()->including(self.oclAsType(Classifier))->exists(name = 'DateTime')
    else false endif;

query NamedElement::isTimeType() : Boolean =
    if self.oclIsKindOf(Classifier)
    then self.oclAsType(Classifier).allParents()->including(self.oclAsType(Classifier))->exists(name = 'Time')
    else false endif;

query NamedElement::isDataElement() : Boolean = false;

query NamedElement::isAttribute() : Boolean = self.getAppliedStereotype('EECProfile::Attribute') <> null;
