/**
 * Copyright (c) 2015 Denis Nikiforov.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *    Denis Nikiforov - initial API and implementation
 */

// There are some XPath AST simplifications in the code.
// It would be great to separate them from the transformation,
// but the problem is that simplification mapping should traverse
// whole AST and therefore it will be even more complex than an
// OCL to XPath transformation itself.

import uml2xsd.UtilitiesLibrary;
import Helpers;

modeltype OCL 'strict' uses 'http://www.eclipse.org/ocl/2015/Pivot';
modeltype XPATH2 'strict' uses 'http://www.emftext.org/language/xpath2';
modeltype JAVA uses 'http://www.emftext.org/java';
modeltype TYPE uses 'http://www.eclipse.org/emf/2003/XMLType';

library OCLtoJava;

mapping ExpressionInOCL::toXPath() : JAVA::expressions::ExpressionList
{
    log('    Transforming OCL expression\n      ' + self.body.replaceAll('\n', '\n      '));
    expressions := self.ownedBody.xmap toExpression();
    log('    to\n      ' + result.toString());
}

mapping OCLExpression::toExpression() : JAVA::expressions::Expression
disjuncts
    // Logic
    OperationCallExp::toOrExpr,
    OperationCallExp::andExpr,
    OperationCallExp::implication,
    IteratorExp::exists,
    IteratorExp::forAll,
    // Comparision
    OperationCallExp::leftNotNull,
    OperationCallExp::rightNotNull,
    OperationCallExp::toComparisonExpr,
    // Arithmetic
    OperationCallExp::toAdditiveExpr,
    OperationCallExp::toMultiplicativeExpr,
    // Path
    PropertyCallExp::toPath,
    // Functions
    OperationCallExp::asSet,
    OperationCallExp::count,
    OperationCallExp::stringLength,
    OperationCallExp::isEmpty,
    OperationCallExp::notEmpty,
    OperationCallExp::sum,
    // Literals
    IntegerLiteralExp::toLiteral,
    UnlimitedNaturalLiteralExp::toLiteral,
    RealLiteralExp::toLiteral,
    StringLiteralExp::toLiteral,
    BooleanLiteralExp::toLiteral,
    // Unknown expressions
    OCLExpression::riseError
{}

//////////////////////////////////////////////////////////////////////////////
// Logic

mapping OperationCallExp::toOrExpr() : JAVA::expressions::Expression
when { self.referredOperation.isBooleanOperation('or') }
{
    init {
        result := self.ownedSource.xmap toExpression().orExpr(
            self.ownedArguments->first().xmap toExpression());
    }
}

mapping OperationCallExp::andExpr() : JAVA::expressions::ConditionalAndExpression
when { self.referredOperation.isBooleanOperation('and') }
{
    children := self.ownedSource.xmap toExpression().andExprOperand();
    children += self.ownedArguments->first().xmap toExpression().andExprOperand();
}

mapping OperationCallExp::implication() : JAVA::expressions::Expression
when { self.referredOperation.isBooleanOperation('implies') }
{
    init {
        result := self.ownedSource.xmap toExpression().notExpr().orExpr(
            self.ownedArguments->first().xmap toExpression());
    }
}

mapping IteratorExp::exists() : FunctionCall
when { self.referredIteration.name = 'exists' }
{
    init {
        var path := self.ownedSource.oclAsType(PropertyCallExp).xmap toPath();
        path.getLastAxisStep().predicate := self.ownedBody.xmap toExpression().predicate();
        result := path.booleanExpr();
    }
}

mapping IteratorExp::forAll() : JAVA::expressions::Expression
when { self.referredIteration.name = 'forAll' }
{
    init {
        var path := self.ownedSource.oclAsType(PropertyCallExp).xmap toPath();
        path.getLastAxisStep().predicate := self.ownedBody.xmap toExpression().notExpr().predicate();
        result := path.notExpr();
    }
}

property fn_not : QName = 'not'.createFunctionQName();
property fn_boolean : QName = 'boolean'.createFunctionQName();

query JAVA::expressions::Expression::booleanExpr() : FunctionCall = object FunctionCall { name := fn_boolean; arg := self; };

query JAVA::expressions::Expression::notExpr() : JAVA::expressions::Expression =
    // Simplification: fn:not(fn:not(...)) = fn:boolean(...)
    if self.isFunctionCall(fn_not) then
        self.oclAsType(FunctionCall).arg->collectOne(booleanExpr())
    // Simplification: fn:not(fn:not(...) and fn:not(...) and ...) = (... or ... or ...)
    elif self.oclIsKindOf(JAVA::expressions::ConditionalAndExpression) and self.oclAsType(AndExpr).operand->forAll(isFunctionCall(fn_not)) then
        object OrExpr { operand :=
            self.oclAsType(JAVA::expressions::ConditionalAndExpression).children->collect(
                oclAsType(FunctionCall).arg->first().orExprOperand()) }
    // Simplification: fn:not(fn:not(...) or fn:not(...) or ...) = (... and ... and ...)
    elif self.oclIsKindOf(JAVA::expressions::ConditionalOrExpression) and self.oclAsType(JAVA::expressions::ConditionalOrExpression).operand->forAll(isFunctionCall(fn_not)) then
        object AndExpr { operand :=
            self.oclAsType(JAVA::expressions::ConditionalOrExpression).operand->collect(
                oclAsType(FunctionCall).arg->first().andExprOperand()) }
    else
        object FunctionCall { name := fn_not; arg := self; }
    endif;

query JAVA::expressions::Expression::orExpr(rhs : JAVA::expressions::Expression) : JAVA::expressions::Expression
{
    var operands := self.orExprOperand();
    operands += rhs.orExprOperand();
    return 
    // Simplification: fn:not(...) or fn:not(...) = fn:not(... and ...)
    if operands->forAll(isFunctionCall(fn_not)) then
        object JAVA::expressions::ConditionalAndExpression { children :=
            operands->collect(
                oclAsType(FunctionCall).arg->first().andExprOperand()) }.notExpr()
    else
        object JAVA::expressions::ConditionalOrExpression { children := operands }
    endif;
}

query JAVA::expressions::Expression::orExprOperand() : OrderedSet(JAVA::expressions::ConditionalOrExpressionChild) =
    // Simplification: (... or ...) or ... = ... or ... or ...
    if self.oclIsKindOf(JAVA::expressions::ConditionalOrExpression) then
        self.oclAsType(JAVA::expressions::ConditionalOrExpression).children
    // Simplification: (...) or ... = ... or ...
    elif self.oclIsKindOf(JAVA::expressions::ConditionalOrExpressionChild) then
        self.oclAsType(JAVA::expressions::ConditionalOrExpressionChild)->asOrderedSet()
    else
        object JAVA::expressions::NestedExpression { expression := self }->asOrderedSet()
    endif;

query JAVA::expressions::Expression::andExprOperand() : OrderedSet(JAVA::expressions::ConditionalAndExpressionChild) =
    // Simplification: (... and ...) and ... = ... and ... and ...
    if self.oclIsKindOf(JAVA::expressions::ConditionalAndExpression) then
        self.oclAsType(JAVA::expressions::ConditionalAndExpression).children
    // Simplification: (...) and ... = ... and ...
    elif self.oclIsKindOf(JAVA::expressions::ConditionalAndExpressionChild) then
        self.oclAsType(JAVA::expressions::ConditionalAndExpressionChild)->asOrderedSet()
    else
        object JAVA::expressions::NestedExpression { expression := self }->asOrderedSet()
    endif;

query PathExpr::getLastAxisStep() : AxisStep
{
    var lastStep = self.step->last();
    var axisStep : AxisStep;
    if (lastStep.oclIsKindOf(SelfStepExpr)) {
        axisStep := lastStep.oclAsType(SelfStepExpr).step.oclAsType(AxisStep);
    }
    elif (lastStep.oclIsKindOf(ChildStepExpr)) {
        axisStep := lastStep.oclAsType(ChildStepExpr).step.oclAsType(AxisStep);
    };
    assert fatal (axisStep <> null) with log('Last AxisStep not found');
    return axisStep;
} 

query JAVA::expressions::Expression::predicate() : Predicate =
    object Predicate { expr :=
        // Simplification: ...[fn:boolean(...)] = ...[...]
        if self.isFunctionCall(fn_boolean) then
            self.oclAsType(FunctionCall).arg->first()
        else
            self
        endif };

//////////////////////////////////////////////////////////////////////////////
// Comparision

mapping OperationCallExp::leftNotNull() : JAVA::expressions::Expression
when { self.name = '<>' and self.ownedArguments->isNullLiteralExp() }
{
    init {
        result := self.ownedSource.xmap toExpression();
    }
}

mapping OperationCallExp::rightNotNull() : JAVA::expressions::Expression
when { self.name = '<>' and self.ownedSource.isNullLiteralExp() }
{
    init {
        result := self.ownedArguments->first().xmap toExpression();
    }
}

mapping OperationCallExp::toComparisonExpr() : JAVA::expressions::RelationExpression
when { self.name.toGeneralComp() <> null and not(self.ownedSource.isNullLiteralExp() or self.ownedArguments->isNullLiteralExp()) }
{
    children := self.ownedSource.xmap toExpression().comparisonExprChild();
    relationOperators := self.name.toGeneralComp();
    children += self.ownedArguments->first().xmap toExpression().comparisonExprChild();
}

query JAVA::expressions::Expression::comparisonExprChild() : JAVA::expressions::RelationExpressionChild =
    // Simplification: (...) <> (...) = ... <> ...
    if self.oclIsKindOf(JAVA::expressions::RelationExpressionChild) then
        self.oclAsType(JAVA::expressions::RelationExpressionChild)
    else
        object JAVA::expressions::NestedExpression { expression := self }
    endif;

query OCLExpression::isNullLiteralExp() : Boolean = self.oclIsKindOf(NullLiteralExp);

query OrderedSet(OCLExpression)::isNullLiteralExp() : Boolean =
    self->size() = 1 and self->first().oclIsKindOf(NullLiteralExp);

query String::toGeneralComp() : JAVA::operators::RelationOperator =
      if (self = "=")  then object JAVA::operators::Equal { }
    elif (self = "<>") then object JAVA::operators::NotEqual { }
    elif (self = "<")  then object JAVA::operators::LessThan { }
    elif (self = "<=") then object JAVA::operators::LessThanOrEqual { }
    elif (self = ">")  then object JAVA::operators::GreaterThan { }
    elif (self = ">=") then object JAVA::operators::GreaterThanOrEqual { }
    endif;

//////////////////////////////////////////////////////////////////////////////
// Arithmetic

mapping OperationCallExp::toAdditiveExpr() : JAVA::expressions::AdditiveExpression
when { self.name.toAdditiveOp() <> null }
{
    var lhs := self.ownedSource.xmap toExpression().additiveExprOperand();
    var rhs := self.ownedArguments->first().xmap toExpression().additiveExprOperand();
    children := lhs.children;
    children += rhs.children;
    additiveOperators := lhs.additiveOperators;
    additiveOperators += self.name.toAdditiveOp();
    additiveOperators += rhs.additiveOperators;
}

mapping OperationCallExp::toMultiplicativeExpr() : JAVA::expressions::MultiplicativeExpression
when { self.name.toMultiplicativeOp() <> null }
{
    var lhs := self.ownedSource.xmap toExpression().multiplicativeExprOperand();
    var rhs := self.ownedArguments->first().xmap toExpression().multiplicativeExprOperand();
    children := lhs.children;
    children += rhs.children;
    multiplicativeOperators := lhs.multiplicativeOperators;
    multiplicativeOperators += self.name.toMultiplicativeOp();
    multiplicativeOperators += rhs.multiplicativeOperators;
}

query JAVA::expressions::Expression::additiveExprOperand() : JAVA::expressions::AdditiveExpression =
    // Simplification: (... + ...) - ... = ... + ... - ...
    if self.oclIsKindOf(JAVA::expressions::AdditiveExpression) then
        self.oclAsType(JAVA::expressions::AdditiveExpression)
    // Simplification: (...) + ... = ... + ...
    elif self.oclIsKindOf(JAVA::expressions::AdditiveExpressionChild) then
        object JAVA::expressions::AdditiveExpression { children := self.oclAsType(JAVA::expressions::AdditiveExpressionChild); }
    else
        object JAVA::expressions::AdditiveExpression { children := object JAVA::expressions::NestedExpression { expression := self } }
    endif;

query JAVA::expressions::Expression::multiplicativeExprOperand() : JAVA::expressions::MultiplicativeExpression =
    // Simplification: (... * ...) / ... = ... * ... / ...
    if self.oclIsKindOf(JAVA::expressions::MultiplicativeExpression) then
        self.oclAsType(JAVA::expressions::MultiplicativeExpression)
    // Simplification: (...) * ... = ... * ...
    elif self.oclIsKindOf(JAVA::expressions::MultiplicativeExpressionChild) then
        object JAVA::expressions::MultiplicativeExpression { children := self.oclAsType(JAVA::expressions::MultiplicativeExpressionChild); }
    else
        object JAVA::expressions::MultiplicativeExpression { children := object JAVA::expressions::NestedExpression { expression := self } }
    endif;

query String::toAdditiveOp() : JAVA::operators::Operator =
      if (self = "+") then object JAVA::operators::Addition { }
    elif (self = "-") then object JAVA::operators::Subtraction { }
    endif;

query String::toMultiplicativeOp() : JAVA::operators::MultiplicativeOperator =
      if (self = "*")   then object JAVA::operators::Multiplication { }
    elif (self = "/")   then object JAVA::operators::Division { }
    elif (self = "div") then object JAVA::operators::Division { } // TODO: Must be a division of integers
    elif (self = "mod") then object JAVA::operators::Remainder { }
    endif;

//////////////////////////////////////////////////////////////////////////////
// Path

mapping PropertyCallExp::toPath() : PathExpr
{
    init {
        // PropertyCallExp tree must be flattened.
        // VariableExp (self or iterator variable) is the innermost
        // component in an input tree, but it should be a first step
        // in an output path.
        result := self.ownedSource[PropertyCallExp]->collectOne(xmap toPath());
    }
    // Steps must be created only for Data Types. Data Elements must be skipped
    if (self.referredProperty.owningClass.isDataType()) {
        // Type can be a Set(T)
        var type := self.referredProperty.type.unwrap();
        
        var element : NamedElement;
        // Property is local
        if (type.isDataType()) {
            element := self.referredProperty;
        }
        // Property is a reference to a global element or attribute
        elif (type.isDataElement()) {
            element := type;
        }
        else {
            assert fatal (true) with log('Something is wrong');
        };

        var stepItem : AbbrevForwardStep;
        if (self.referredProperty.isAttribute()) {
            stepItem := object AbbrevForwardStep {
                kind := AbbrevForwardStepKind::attribute;
                nodeTest := object QNameTest { name := element.getUnprefixedQName() };
            };
        }
        else {
            stepItem := object AbbrevForwardStep {
                kind := AbbrevForwardStepKind::child;
                nodeTest := object QNameTest { name := element.getQName() };
            };
        };
        
        if (step->isEmpty()) {
            step := object SelfStepExpr { step := stepItem };
        }
        else {
            step += object ChildStepExpr { step := stepItem };
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
// Functions

mapping OperationCallExp::asSet() : JAVA::expressions::Expression
when { self.referredOperation.name = 'oclAsSet' }
{
    init {
        result := self.ownedSource.xmap toExpression();
    }
}

mapping OperationCallExp::count() : FunctionCall
when { self.referredOperation.name = 'size' and self.referredOperation.isCollectionOperation() }
{
    name := 'count'.createFunctionQName();
    arg := self.ownedSource.xmap toExpression();
}

mapping OperationCallExp::stringLength() : FunctionCall
when { self.referredOperation.name = 'size' and not self.referredOperation.isCollectionOperation() }
{
    name := 'string-length'.createFunctionQName();
    arg := self.ownedSource.xmap toExpression();
}

mapping OperationCallExp::isEmpty() : JAVA::expressions::Expression
when { self.referredOperation.name = 'isEmpty' }
{
    init {
    	result := self.ownedSource.xmap toExpression().notExpr();
    }
}

mapping OperationCallExp::notEmpty() : FunctionCall
when { self.referredOperation.name = 'notEmpty' }
{
    init {
        result := self.ownedSource.xmap toExpression().booleanExpr();
    }
}

mapping OperationCallExp::sum() : FunctionCall
when { self.referredOperation.name = 'sum' and self.referredOperation.isCollectionOperation() }
{
    name := 'sum'.createFunctionQName();
    arg := self.ownedSource.xmap toExpression();
}

//////////////////////////////////////////////////////////////////////////////
// Literals

mapping IntegerLiteralExp::toLiteral() : JAVA::literals::DecimalIntegerLiteral
{
    decimalValue := self.integerSymbol.oclAsType(Integer);
}

mapping UnlimitedNaturalLiteralExp::toLiteral() : JAVA::literals::DecimalIntegerLiteral
{
    decimalValue := self.unlimitedNaturalSymbol.oclAsType(Integer);
}

mapping RealLiteralExp::toLiteral() : JAVA::literals::DecimalDoubleLiteral
{
    init {
        var val := self.realSymbol.repr().toReal();
        result := if (val.repr().matches('.+[eE].+'))
            then object JAVA::literals::DecimalDoubleLiteral { decimalValue := val }
            else object JAVA::literals::DecimalDoubleLiteral { decimalValue := val } endif;
    }
}

mapping StringLiteralExp::toLiteral() : JAVA::_references::StringReference
{
    value := self.stringSymbol.quote();
}

mapping BooleanLiteralExp::toLiteral() : JAVA::literals::BooleanLiteral
{
    value := self.booleanSymbol;
}

//////////////////////////////////////////////////////////////////////////////
// Unknown expressions

mapping OCLExpression::riseError() : JAVA::_references::StringReference
{
    assert fatal (false) with log('Unknown ' + self.metaClassName() + ' ' + self.repr());
}

//////////////////////////////////////////////////////////////////////////////
// Helpers

query NamedElement::unwrap() : NamedElement =
    if self.oclIsKindOf(SetType) then self.oclAsType(SetType).elementType else self endif;

query NamedElement::getQName() : QName = self.getETarget().getQName();

query NamedElement::getUnprefixedQName() : QName = self.getETarget().getUnprefixedQName();

query NamedElement::isDataType() : Boolean = self.getETarget().isDataType();

query NamedElement::isDataElement() : Boolean = self.getETarget().isDataElement();

query Property::isAttribute() : Boolean = self.getETarget().isAttribute();

query Operation::isBooleanOperation(name : String) : Boolean = 
    self.owningClass.oclIsKindOf(PrimitiveType) and
    self.owningClass.name = 'Boolean' and
    self.name = name;

query Operation::isCollectionOperation() : Boolean = 
    self.owningClass.oclIsKindOf(CollectionType);

query JAVA::expressions::Expression::isFunctionCall(name : QName) : Boolean =
    self.oclIsKindOf(FunctionCall) and self.oclAsType(FunctionCall).name = name;

query String::createFunctionQName() : QName =
    createQName('http://www.w3.org/2005/xpath-functions', self, 'fn');
