import uml2xsd.UtilLib;
import Helpers;

modeltype OCL 'strict' uses 'http://www.eclipse.org/ocl/3.1.0/Pivot';
modeltype XPATH2 'strict' uses 'http://www.emftext.org/language/xpath2';
modeltype TYPE uses 'http://www.eclipse.org/emf/2003/XMLType';

library OCLtoXPath;

mapping ExpressionInOCL::toXPath() : Expr
{
    log("  Transforming OCL expression\n    " + self.body->first().replaceAll('\n', '\n    '));
    expr := self.bodyExpression.map toExprSingle();
}

mapping OCLExpression::toExprSingle() : ExprSingle
disjuncts
    OperationCallExp::leftNotNull,
    OperationCallExp::rightNotNull,
    OperationCallExp::toIfExpr,
    OperationCallExp::toOrExpr,
    OCLExpression::toOrExprChild
{}

mapping OperationCallExp::toIfExpr() : OrExpr
when { self.name = 'implies' }
{
    operand := self.source.xmap toExprSingle().notExpr();
    operand += self.argument[OCLExpression].xmap toOrExprChild();
}

mapping OperationCallExp::toOrExpr() : OrExpr
when { self.name = 'or' }
{
    init {
        // It's not necessary, but it's better to flatten a left recursion.
        result := self.source[OperationCallExp]->collectOne(map toOrExpr());
    }
    if (operand->isEmpty()) {
        operand := self.source.xmap toOrExprChild();
    } endif;
    operand += self.argument->toOrExprChild();
}

mapping OCLExpression::toOrExprChild() : OrExprChild
disjuncts
    OperationCallExp::toAndExpr,
    OCLExpression::toAndExprChild
{}

mapping OperationCallExp::toAndExpr() : AndExpr
when { self.name = 'and' }
{
    init {
        result := self.source[OperationCallExp]->collectOne(map toAndExpr());
    }
    if (operand->isEmpty()) {
        operand := self.source.xmap toAndExprChild();
    } endif;
    operand += self.argument->toAndExprChild();
}

mapping OCLExpression::toAndExprChild() : AndExprChild
disjuncts
    OperationCallExp::toComparisonExpr,
    OCLExpression::toComparisonExprChild
{}

mapping OperationCallExp::leftNotNull() : ExprSingle
when { self.name = '<>' and self.argument->isNullLiteralExp() }
{
    init {
        result := self.source.xmap toExprSingle();
    }
}

mapping OperationCallExp::rightNotNull() : ExprSingle
when { self.name = '<>' and self.source.isNullLiteralExp() }
{
    init {
        result := self.argument->first().xmap toExprSingle();
    }
}


mapping OperationCallExp::toComparisonExpr() : ComparisonExpr
when { self.name.toGeneralComp() <> null and not(self.source.isNullLiteralExp() or self.argument->isNullLiteralExp()) }
{
    left := self.source.xmap toComparisonExprChild();
    operator := object GeneralComp { operator := self.name.toGeneralComp() };
    right := self.argument->first().xmap toComparisonExprChild();
}

mapping OCLExpression::toComparisonExprChild() : ComparisonExprChild
disjuncts
    OperationCallExp::toAdditiveExpr,
    OCLExpression::toAdditiveExprChild
{}

mapping OperationCallExp::toAdditiveExpr() : AdditiveExpr
when { self.name.toAdditiveOp() <> null }
{
    init {
        result := self.source[OperationCallExp]->collectOne(map toAdditiveExpr());
    }
    if (operand->isEmpty()) {
        operand := self.source.xmap toAdditiveExprChild();
    } endif;
    operand += self.argument->toAdditiveExprChild();
    operator += self.name.toAdditiveOp();
}

mapping OCLExpression::toAdditiveExprChild() : AdditiveExprChild
disjuncts
    OperationCallExp::toMultiplicativeExpr,
    OCLExpression::toMultiplicativeExprChild
{}

mapping OperationCallExp::toMultiplicativeExpr() : MultiplicativeExpr
when { self.name.toMultiplicativeOp() <> null }
{
    init {
        result := self.source[OperationCallExp]->collectOne(map toMultiplicativeExpr());
    }
    if (operand->isEmpty()) {
        operand := self.source.xmap toMultiplicativeExprChild();
    } endif;
    operand += self.argument->toMultiplicativeExprChild();
    operator += self.name.toMultiplicativeOp();
}

mapping OCLExpression::toMultiplicativeExprChild() : MultiplicativeExprChild
disjuncts
    PropertyCallExp::toPath,
    OperationCallExp::count,
    OperationCallExp::stringLength,
    IteratorExp::exists,
    IteratorExp::forAll,
    UnlimitedNaturalLiteralExp::toLiteral,
    RealLiteralExp::toLiteral,
    StringLiteralExp::toLiteral,
    OCLExpression::toParenthesizedExpr
{}

mapping PropertyCallExp::toPath() : PathExpr
{
    init {
        result := self.source[PropertyCallExp]->collectOne(xmap toPath());
    }
    if (self.source[VariableExp]->one(referredVariable.name = 'self')) {
        assert fatal (self.referredProperty.owningType.oclIsKindOf(DataType))
            with log('Constraint could not be defined for a Data Element \'' +
                self.referredProperty.owningType.name + '\'. Please define the constraint for a Data Type \'' +
                self.referredProperty.type.name + '\'');
        if (self.referredProperty.getETarget().getAppliedStereotype('EECProfile::Attribute') = null) {
            step := object SelfStepExpr { step := object AbbrevForwardStep {
                kind := AbbrevForwardStepKind::child;
                nodeTest := object QNameTest { name := self.referredProperty.type.getQName() } } };
        }
        else {
            step := object SelfStepExpr { step := object AbbrevForwardStep {
                kind := AbbrevForwardStepKind::attribute;
                nodeTest := object QNameTest { name := self.referredProperty.type.getUnprefixedQName() } } };
        }
    }
    else if (self.source[PropertyCallExp]->notEmpty()) {
        if (self.referredProperty.owningType.oclIsKindOf(DataType)) {
            if (self.referredProperty.type.oclIsKindOf(DataType)) {
                step += self.referredProperty.xmap toChildStepExpr();
            }
            else {
                step += self.referredProperty.type.xmap toChildStepExpr();
            }
        }
        else {
            assert fatal (self.referredProperty.type.oclIsKindOf(DataType))
                with log('Data Element \'' + self.referredProperty.owningType.name + '\' must have a Data Type');
        }
    }
}

mapping NamedElement::toChildStepExpr() : ChildStepExpr
disjuncts
    NamedElement::toChildStepExprFromElement,
    NamedElement::toChildStepExprFromAttribute
{}

mapping NamedElement::toChildStepExprFromElement() : ChildStepExpr
when { self.getETarget().getAppliedStereotype('EECProfile::Attribute') = null }
{
    step := object AbbrevForwardStep {
       kind := AbbrevForwardStepKind::child;
       nodeTest := object QNameTest { name := self.getQName() }
    }
}

mapping NamedElement::toChildStepExprFromAttribute() : ChildStepExpr
when { self.getETarget().getAppliedStereotype('EECProfile::Attribute') <> null }
{
    step := object AbbrevForwardStep {
       kind := AbbrevForwardStepKind::attribute;
       nodeTest := object QNameTest { name := self.getUnprefixedQName() }
    }
}

mapping OperationCallExp::count() : FunctionCall
when { self.referredOperation.name = 'size' and self.referredOperation.owningType.name = 'Collection' }
{
    name := createQName('http://www.w3.org/2005/xpath-functions', 'count', 'fn');
    arg := self.source.xmap toExprSingle();
}

mapping OperationCallExp::stringLength() : FunctionCall
when { self.referredOperation.name = 'size' and self.referredOperation.owningType.name = 'String' }
{
    name := createQName('http://www.w3.org/2005/xpath-functions', 'string-length', 'fn');
    arg := self.source.xmap toExprSingle();
}

mapping IteratorExp::exists() : FunctionCall
when { self.referredIteration.name = 'exists' }
{
    init {
        result := object FilterExpr {
            primaryExpr := object ParenthesizedExpr { expr := self.source.xmap toExprSingle() };
            predicate := object Predicate { expr := self.body.xmap toExprSingle() };
        }.booleanExpr();
    }
}

mapping IteratorExp::forAll() : FunctionCall
when { self.referredIteration.name = 'forAll' }
{
    init {
        result := object FilterExpr {
            primaryExpr := object ParenthesizedExpr { expr := self.source.xmap toExprSingle() };
            predicate := object Predicate { expr := self.body.xmap toExprSingle().notExpr() };
        }.notExpr();
    }
}

mapping OperationCallExp::forAll() : FunctionCall
{
    name := createQName('http://www.w3.org/2005/xpath-functions', 'forAll', 'fn');
    arg := self.source.xmap toExprSingle();
}

mapping UnlimitedNaturalLiteralExp::toLiteral() : IntegerLiteral
{
    value := self.unlimitedNaturalSymbol.oclAsType(Integer);
}

mapping RealLiteralExp::toLiteral() : NumericLiteral
{
    init {
        var val := self.realSymbol.repr().toReal();
        result := if (val.repr().matches('.+[eE].+'))
            then object DoubleLiteral { value := val }
            else object DecimalLiteral { value := val } endif;
    }
}

mapping StringLiteralExp::toLiteral() : StringLiteral
{
    value := self.stringSymbol.quote();
}

mapping OCLExpression::toParenthesizedExpr() : ParenthesizedExpr
//when { self.xmap OclToXpath() <> null }
{
    expr := self.xmap toExprSingle()
}

mapping OCLExpression::toVarRef() : VarRef {
    object VarRef { varName := createQName(self.name) }
}

///////////////////////////////////////////////////////////////////////////////
// Helpers

query NamedElement::getQName() : QName = self.getETarget().getQName();

query NamedElement::getUnprefixedQName() : QName = self.getETarget().getUnprefixedQName();

query String::quote() : String = '\'' + self.replaceAll('\'', '\'\'') + '\'';

query trueExpr() : FunctionCall = object FunctionCall {
    name := createQName('http://www.w3.org/2005/xpath-functions', 'true', 'fn') };

query falseExpr() : FunctionCall = object FunctionCall {
    name := createQName('http://www.w3.org/2005/xpath-functions', 'false', 'fn') };

query ExprSingle::notExpr() : FunctionCall =
    object FunctionCall {
        name := createQName('http://www.w3.org/2005/xpath-functions', 'not', 'fn');
        arg := self; };

query ExprSingle::booleanExpr() : FunctionCall =
    object FunctionCall {
        name := createQName('http://www.w3.org/2005/xpath-functions', 'boolean', 'fn');
        arg := self; };

query OCLExpression::isNullLiteralExp() : Boolean = self.oclIsKindOf(NullLiteralExp);

query OrderedSet(OCLExpression)::isNullLiteralExp() : Boolean =
    self->size() = 1 and self->first().oclIsKindOf(NullLiteralExp);

query String::toGeneralComp() : GeneralCompKind =
  if (self = "=")  then GeneralCompKind::eq
elif (self = "<>") then GeneralCompKind::ne
elif (self = "<")  then GeneralCompKind::lt
elif (self = "<=") then GeneralCompKind::le
elif (self = ">")  then GeneralCompKind::gt
elif (self = ">=") then GeneralCompKind::ge
endif;

query String::toAdditiveOp() : AdditiveOpKind =
  if (self = "+") then AdditiveOpKind::addition
elif (self = "-") then AdditiveOpKind::subtraction
endif;

query String::toMultiplicativeOp() : MultiplicativeOpKind =
  if (self = "*")    then MultiplicativeOpKind::multiplication
elif (self = "div")  then MultiplicativeOpKind::div
elif (self = "idiv") then MultiplicativeOpKind::idiv
elif (self = "mod")  then MultiplicativeOpKind::mod
endif;
