modeltype OCL 'strict' uses 'http://www.eclipse.org/ocl/3.1.0/Pivot';
modeltype XPATH2 'strict' uses 'http://www.emftext.org/language/xpath2';
modeltype XSD uses "http://www.eclipse.org/xsd/2002/XSD";

transformation OclToXpath(in o : OCL, out x : XPATH2);

main() {
//    o.rootObjects()[ExpressionInOCL].map Root2Root();
    var res := object Expr {};
    o.rootObjects()[ExpressionInOCL]->sortedBy(body->first()).map Root2Root()->forEach(e) {
        res.expr += e.expr;
    };
}

mapping ExpressionInOCL::Root2Root() : Expr {
    log("  Transforming " + self.body->first());
    expr := self.bodyExpression.map toExprSingle();
}

mapping OCLExpression::toExprSingle() : ExprSingle
disjuncts
    OperationCallExp::leftNotNull,
    OperationCallExp::rightNotNull,
    OperationCallExp::toIfExpr,
    OperationCallExp::toOrExpr,
    OCLExpression::toOrExprChild
{}

mapping OperationCallExp::toIfExpr() : OrExpr
when { self.name = 'implies' }
{
    operand := self.source.xmap toExprSingle().notExpr();
    operand += self.argument[OCLExpression].xmap toOrExprChild();
}

mapping OperationCallExp::toOrExpr() : OrExpr
when { self.name = 'or' }
{
    init {
        // It's not necessary, but it's better to flatten a left recursion.
        result := self.source[OperationCallExp]->collectOne(map toOrExpr());
    }
    if (operand->isEmpty()) {
        operand := self.source.xmap toOrExprChild();
    } endif;
    operand += self.argument->toOrExprChild();
}

mapping OCLExpression::toOrExprChild() : OrExprChild
disjuncts
    OperationCallExp::toAndExpr,
    OCLExpression::toAndExprChild
{}

mapping OperationCallExp::toAndExpr() : AndExpr
when { self.name = 'and' }
{
    init {
        result := self.source[OperationCallExp]->collectOne(map toAndExpr());
    }
    if (operand->isEmpty()) {
        operand := self.source.xmap toAndExprChild();
    } endif;
    operand += self.argument->toAndExprChild();
}

mapping OCLExpression::toAndExprChild() : AndExprChild
disjuncts
    OperationCallExp::toComparisonExpr,
    OCLExpression::toComparisonExprChild
{}

mapping OperationCallExp::leftNotNull() : ExprSingle
when { self.name = '<>' and self.argument->isNullLiteralExp() }
{
    init {
        result := self.source.xmap toExprSingle();
    }
}

mapping OperationCallExp::rightNotNull() : ExprSingle
when { self.name = '<>' and self.source.isNullLiteralExp() }
{
    init {
        result := self.argument->first().xmap toExprSingle();
    }
}


mapping OperationCallExp::toComparisonExpr() : ComparisonExpr
when { self.name.toGeneralComp() <> null and not(self.source.isNullLiteralExp() or self.argument->isNullLiteralExp()) }
{
    left := self.source.xmap toComparisonExprChild();
    operator := object GeneralComp { operator := self.name.toGeneralComp() };
    right := self.argument->first().xmap toComparisonExprChild();
}

mapping OCLExpression::toComparisonExprChild() : ComparisonExprChild
disjuncts
    OperationCallExp::toAdditiveExpr,
    OCLExpression::toAdditiveExprChild
{}

mapping OperationCallExp::toAdditiveExpr() : AdditiveExpr
when { self.name.toAdditiveOp() <> null }
{
    init {
        result := self.source[OperationCallExp]->collectOne(map toAdditiveExpr());
    }
    if (operand->isEmpty()) {
        operand := self.source.xmap toAdditiveExprChild();
    } endif;
    operand += self.argument->toAdditiveExprChild();
    operator += self.name.toAdditiveOp();
}

mapping OCLExpression::toAdditiveExprChild() : AdditiveExprChild
disjuncts
    OperationCallExp::toMultiplicativeExpr,
    OCLExpression::toMultiplicativeExprChild
{}

mapping OperationCallExp::toMultiplicativeExpr() : MultiplicativeExpr
when { self.name.toMultiplicativeOp() <> null }
{
    init {
        result := self.source[OperationCallExp]->collectOne(map toMultiplicativeExpr());
    }
    if (operand->isEmpty()) {
        operand := self.source.xmap toMultiplicativeExprChild();
    } endif;
    operand += self.argument->toMultiplicativeExprChild();
    operator += self.name.toMultiplicativeOp();
}

mapping OCLExpression::toMultiplicativeExprChild() : MultiplicativeExprChild
disjuncts
    PropertyCallExp::toPath,
    OperationCallExp::count,
    OperationCallExp::stringLength,
    IteratorExp::exists,
    IteratorExp::forAll,
    UnlimitedNaturalLiteralExp::toLiteral,
    RealLiteralExp::toLiteral,
    StringLiteralExp::toLiteral,
    OCLExpression::toParenthesizedExpr
{}

mapping PropertyCallExp::toPath() : PathExpr
{
    init {
        result := self.source[PropertyCallExp]->collectOne(xmap toPath());
    }
    if (self.source[VariableExp]->one(referredVariable.name = 'self')) {
        step := object SelfStepExpr { step := object AbbrevForwardStep {
            kind := AbbrevForwardStepKind::child;
            nodeTest := object QNameTest { name := object QName { name := self.referredProperty.name } } } };
    }
    else if (self.source[PropertyCallExp]->notEmpty()) {
        step += object ChildStepExpr { step := object AbbrevForwardStep {
            kind := AbbrevForwardStepKind::child;
            nodeTest := object QNameTest { name := object QName { name := self.referredProperty.name } } } };
    }
}

mapping OperationCallExp::count() : FunctionCall
when { self.referredOperation.name = 'size' and self.referredOperation.owningType.name = 'Collection' }
{
    name := object QName { prefix := 'fn'; name := 'count' };
    arg := self.source.xmap toExprSingle();
}

mapping OperationCallExp::stringLength() : FunctionCall
when { self.referredOperation.name = 'size' and self.referredOperation.owningType.name = 'String' }
{
    name := object QName { prefix := 'fn'; name := 'string-length' };
    arg := self.source.xmap toExprSingle();
}

mapping IteratorExp::exists() : FunctionCall
when { self.referredIteration.name = 'exists' }
{
    init {
        result := object FilterExpr {
            primaryExpr := object ParenthesizedExpr { expr := self.source.xmap toExprSingle() };
            predicate := object Predicate { expr := self.body.xmap toExprSingle() };
        }.booleanExpr();
    }
}

mapping IteratorExp::forAll() : FunctionCall
when { self.referredIteration.name = 'forAll' }
{
    init {
        result := object FilterExpr {
            primaryExpr := object ParenthesizedExpr { expr := self.source.xmap toExprSingle() };
            predicate := object Predicate { expr := self.body.xmap toExprSingle().notExpr() };
        }.notExpr();
    }
}

mapping OperationCallExp::forAll() : FunctionCall
{
    name := object QName { prefix := 'fn'; name := 'forAll' };
    arg := self.source.xmap toExprSingle();
}

mapping UnlimitedNaturalLiteralExp::toLiteral() : IntegerLiteral
{
    value := self.unlimitedNaturalSymbol.oclAsType(Integer);
}

mapping RealLiteralExp::toLiteral() : NumericLiteral
{
    init {
        var val := self.realSymbol.repr().toReal();
        result := if (val.repr().matches('.+[eE].+'))
            then object DoubleLiteral { value := val }
            else object DecimalLiteral { value := val } endif;
    }
}

mapping StringLiteralExp::toLiteral() : StringLiteral
{
    value := self.stringSymbol.quote();
}

mapping OCLExpression::toParenthesizedExpr() : ParenthesizedExpr
//when { self.xmap OclToXpath() <> null }
{
    expr := self.xmap toExprSingle()
}

mapping OCLExpression::toVarRef() : VarRef {
    object VarRef { varName := object VarName { name := self.name } }
}


// Helpers

query String::quote() : String = '\'' + self.replaceAll('\'', '\'\'') + '\'';

query trueExpr() : FunctionCall = object FunctionCall { name := object QName { prefix := 'fn'; name := 'true' } };

query falseExpr() : FunctionCall = object FunctionCall { name := object QName { prefix := 'fn'; name := 'false' } };

query ExprSingle::notExpr() : FunctionCall =
    object FunctionCall {
        name := object QName { prefix := 'fn'; name := 'not' };
        arg := self; };

query ExprSingle::booleanExpr() : FunctionCall =
    object FunctionCall {
        name := object QName { prefix := 'fn'; name := 'boolean' };
        arg := self; };

query OCLExpression::isNullLiteralExp() : Boolean = self.oclIsKindOf(NullLiteralExp);

query OrderedSet(OCLExpression)::isNullLiteralExp() : Boolean =
    self->size() = 1 and self->first().oclIsKindOf(NullLiteralExp);

query String::toGeneralComp() : GeneralCompKind =
  if (self = "=")  then GeneralCompKind::eq
elif (self = "<>") then GeneralCompKind::ne
elif (self = "<")  then GeneralCompKind::lt
elif (self = "<=") then GeneralCompKind::le
elif (self = ">")  then GeneralCompKind::gt
elif (self = ">=") then GeneralCompKind::ge
endif;

query String::toAdditiveOp() : AdditiveOpKind =
  if (self = "+") then AdditiveOpKind::addition
elif (self = "-") then AdditiveOpKind::subtraction
endif;

query String::toMultiplicativeOp() : MultiplicativeOpKind =
  if (self = "*")    then MultiplicativeOpKind::multiplication
elif (self = "div")  then MultiplicativeOpKind::div
elif (self = "idiv") then MultiplicativeOpKind::idiv
elif (self = "mod")  then MultiplicativeOpKind::mod
endif;
